\section{The certified library \label{Op}}
The functions that are defined in the library are the following:
addition, subtraction, multiplication,  division, square root, gcd, power function
and modulo. 
For each of them, we not only give an implementation but also formally prove 
that this implementation meets its specification. Specifications are expressed 
using predicates over integers. For this, we use two transfer functions.
Given a single word element {\tt x}, its corresponding value as an integer
is denoted as {\tt [|x|]}. Given a two-word element {\tt y}, its corresponding
value as an integer is denoted as {\tt [[y]]}. The maximum value that can be
expressed with one word plus one is {\tt wB}. From these definitions, the 
following statement holds
\begin{verbatim}
forall x y, [[WW x y]] = [|x|] * wB + [|y|].
\end{verbatim}
Using these definitions, it is possible to state the specifications
of the functions of the library. For example, proving that the comparison
function defined in the previous Section is correct, we have to proved
that if the function {\tt w\_compare} meets its specification
\begin{verbatim}
forall x y,
       match w_compare x y with
       | Eq => [|x|] = [|y|]
       | Lt => [|x|] < [|y|]
       | Gt => [|x|] > [|y|]
       end.
\end{verbatim}
so does the function {\tt ww\_compare}
\begin{verbatim}
forall x y,
       match ww_compare x y with
       | Eq => [[x]] = [[y]]
       | Lt => [[x]] < [[y]]
       | Gt => [[x]] > [[y]]
       end.
\end{verbatim}

\subsection{Words and carries}

For some basic functions like addition and substration, their corresponding
modular implementation if considered as a function that takes two words and
returns a word cannot be exact. The result fits in a word plus a carry.  
To represent carries, the only possibility in a functional language is
to integrate it in the result returned by the function 
\begin{verbatim}
Inductive carry (w: Set): Set :=
  | C0 : w -> carry
  | C1 : w -> carry.
\end{verbatim}
Associated to a carry, there are two interpretation functions.
One interprets positively the carry: {\tt [+|C1 x|] = wB + [|x|]} and
{\tt [+|C0 x|] = [|x|]}. The other one interprets it negatively:
{\tt [-|C1 x|] = [|x|] - wB} and
{\tt [-|C0 x|] = [|x|]}.

To illustrate how carries are manipulated, let us consider the successor function.
In our library it is represented by two functions
\begin{verbatim}
w_sub: w -> w -> w
w_sub_c: w -> w -> carry w
\end{verbatim}
The first function represents the modular version, the second one the exact 
version. With these two functions, it is possible to define the version
for two-words element. For example, the definition of the modular one is
\begin{verbatim}
 Definition ww_succ x :=
  match x with
  | W0 => WW w_0 w_1
  | WW xh xl =>
    match w_succ_c xl with
    | C0 l => WW xh l
    | C1 l => WW (w_succ xh) w_0
    end
  end.
\end{verbatim}
Note that contrary to what happens in imperative languages like C, returning
a carry allocates a memory cell. This has some impact on the implementation:
we try as much as possible to avoid creating them.
For some critical pieces of code we use a continuation passing style,
where functions take two extra arguments that are continuations.
The first continuation corresponds to the code that is called when there is a carry and
the second one when there is not. Another situation that occurs often is when
we know in advance that the result always returns (or similarly always not return a carry).
In that case, we can call directly the modular function. It is  in proving that the
function meets its specification that we will have to justify this knowledge.
An example of such a situation is a naive implementation of the exact function that adds two to a one
word element by calling twice the successor function.
\begin{verbatim}
 Definition w_add2 x :=
  match w_succ_c x with
  | C0 y => w_succ_c y
  | C1 y => C1 (w_succ y)
  end.
\end{verbatim}
In the case where the first increments has created a carry, we are sure that the second
increment cannot raise any carry so we can directly call the {\tt w\_succ} function.

\subsection{Moving bits}

If most of the operations works at word level, some functions like the
shifting operation requires to work at a finer level, the level of bits.
Surprising all the operations we had to perform at bit levels can be built
on top of  one single function
\begin{verbatim}
w_add_mul_div : positive -> w -> w -> w
\end{verbatim}
Evaluating  {\tt (w\_add\_mul\_div p x y)} returns a new word that
is composed for its {\tt p} first bits by the last bits of {\tt x}
and for the remaining bits by the first bits of {\tt y}.
Its specification is the following
\begin{verbatim}
forall x y p, 
 2 ^ p < wB  ->
 [|w_add_mul_div p x y|] =
    ([|x|] * (2 ^ p) + ([|y|] * (2 ^ p)) / wB) mod wB.
\end{verbatim}
Two degenerated versions of this function are of some direct interest. Calling
{\tt w\_add\_mul\_div} with a zero word as second argument implements
the shift left. Calling it with a zero word as third argument implements
the shift right.

\subsection{Divide and conquer algorithms}

\subsubsection{Karatsuba multiplication}
To speed up multiplication was the original motivation of our 
tree representation of numbers. It is represented in our library
by the function
\begin{verbatim}
w_mul: w -> w -> w2 w
\end{verbatim}
and its specification is
\begin{verbatim}
forall x y, [[ w_mul_c x y ]] = [|x|] * [|y|]
\end{verbatim}
The naive implementation on two-word elements follows the simple equation
\begin{verbatim}
[[WW aH aL]] * [[WW bH bL]] =
  [|aH|] * [|bH|] * wB ^ 2 + 
     ([|aH|] * [|bL|] + [|aL|] * [|bH|]) * wB + [|aL|] * [|bL|]
\end{verbatim}
Performing a multiplication requires four submultiplications.
Karatsuba multiplication~\cite{Karat} saves one of these submultiplications
\begin{verbatim}
[[WW aH aL]] * [[WW bH bL]] =
  let v1 := [|aH|] * [|bH|] in
  let v2 := [|aL|] * [|bL|] in
  v1 + (([|aH|] + [|bL|]) * ([|aL|] + [|bH|]) - v1 - v2) * wB + v2
\end{verbatim}
Note that Karatsuba multiplication is more effective than the naive one
only when numbers are getting large enough. This means that our library
includes the two implementations. They are used to define two
different functors. The functor with the naive multiplication to
build operations for trees of small height.

\subsubsection{Recursive Division}
The general division algorithm that we have implemented is the usual schoolboy 
method that iterates the division of two words by one word. 
The key point is how to perform this last division efficiently. 
The algorithm we have implemented is described in~\cite{RecDiv}.
The idea is first to use a recursive call to guess an approximation 
of the quotient and  then to perform an adjustment in order to get the proper quotient.

In our development, the division two by one on single words takes
three words and returns a pair composed of the quotient and the remainder.
\begin{verbatim}
Variable w_div21: w -> w -> w -> w * w
\end{verbatim}
and its specification is 
\begin{verbatim}
forall a1 a2 b,  [|a1|] < [|b|] -> wB / 2 <= [|b|] -> 
  let (q, r) := w_div21 a1 a2 b in
   [|a1|] * wB + [|a2|] = [|q|] * [|b|] + [|r|] /\ 
    0 <= [|r|] < [|b|].
\end{verbatim}
Only the two conditions deserve some explanation.
The first one ensures that the quotient fits in one word.
The second one requires the first bit of the divisor to be a 
one. It ensures that the recursive call computes an approximation 
of the quotient that is not too far from the correct value.

Before defining the function {\tt ww\_div21} for two-word elements,
we need to define the intermediate function  {\tt w\_div32}
that divides three one-word elements by two one-word elements.
Its specification is
\begin{verbatim}
forall a1 a2 a3 b1 b2, 
  [[WW a1 a2]] < [[WW b1 b2]] -> wB / 2 <= [|b1|] ->
  let (q, r) := w_div32 a1 a2 a3 b1 b2 in
  [|a1|] * wB ^ 2 + [|a2|] * wB  + [|a3|] =  
      [|q|] *  ([|b1|] * wB + [|b2|])  + [[r]] /\ 
  0 <= [[r]] < [|b1|] * wB + [|b2|].
\end{verbatim}
The two conditions play the same rôles than the ones for the specification of {\tt w\_div21}.
As the code is a bit intricate, we just explain here how the function
proceeds. It first calls {\tt w\_div21} to divide {\tt a1} and {\tt a2}
by {\tt b1}. This gives a pair {\tt q} and {\tt r} such that
\begin{verbatim}
 [|a1|] * wB + [|a2|] = [|q|] * [|b1|] + [|r|]
\end{verbatim}
{\tt q} is considered as the approximation of quotient.
The second condition in the specification ensures that if this approximation
is not exact, it exceeds the real value of at most two units. So the quotient 
can only be {\tt q}, {\tt q - 1} or {\tt q - 2}. 
As we have 
\begin{verbatim}
 [|a1|] *  wB ^ 2  + [|a2|] * wB + [|a3|] = 
   [|q|] * ([|b1|] * wB  + [|b2|]) + ([|r|] * wB - [|q|] * [|b2|])
\end{verbatim}
we know in which situation we are by testing the sign of the candidate
remainder.
In our modular arithmetic, it amounts in checking if the substraction   {\tt (WW r wO) - (q * b2)} 
produces or not a carry.  
If it is positive (no carry), the quotient is {\tt q}. If it is negative (a carry), we
have to consider {\tt q - 1} and add in consequence {\tt (WW b1 b2)} to the candidate remainder.
We test again the sign of this new candidate. If it is positive, the quotient is {\tt q - 1}
otherwise it is {\tt q - 2}.
Now the definition of {\tt ww\_div21} is straightforward. Not considering the cases for the {\tt W0}
constructor, we get
\begin{verbatim} 
 Definition ww_div21 a1 a2 b :=
  match a1, a2, b with
  ....  
  | WW a1H a1L, WW a2H a2L, WW bH bL =>
        let (q1, r) := w_div32 a1H a1L a2H bH bL in
        match r with
        | W0 => (WW q1 w_0, W0W a2l)
        | WW rH rL =>
          let (q2, s) := w_div32 rH rL a2L b1 b2 in
          (WW q1 q2, s)
        end
  end.
\end{verbatim}
Dividing with {\tt w\_div32} the high part of {\tt a1}, the low part of {\tt a1} and the high part of {\tt a2}
by the high and low parts of {\tt b} gives the high part of the quotient. Dividing again with {\tt w\_div32} 
the high part of the remainder, the low part of the remainder, the low part of {\tt a2} by the high and 
low parts of {\tt b} gives  the low part of the quotient and the remainder.
  
\subsubsection{Recursive Square Root}

The algorithm for computing the square root is similar to the one for division.
It was first described in~\cite{RecSqrt} and has already been formalized in a 
theorem prover~\cite{BerMagZim02}. It requires the number to be splitted
in four. For this reason it is represented by the following function in our
library
\begin{verbatim}
w_sqrt: w -> w -> w * carry w;
\end{verbatim}
it returns the square root and the rest.
Its specification is
\begin{verbatim}
forall x y,
    wB / 4 <= [|x|] ->
    let (s,r) := w_sqrt2 x y in
    [[WW x y]] = [[s]] ^ 2 + [+|r|] /\ [+|r|] <= 2 * [|s|]
\end{verbatim}
As for the division, the input must be sufficient large so that the recursive call
that computes the approximation is accurate enough. 

The definition of the square root needs a support function that implements a division
by two times a number
\begin{verbatim}
w_div2s: carry w -> w -> w -> carry w * carry w
\end{verbatim}
with its specification
\begin{verbatim}
 forall a1 a2 b,
     wB/2 <= [|b|] -> [+|a1|] <= 2 * [|b|] ->
     let (q,r) := w_div2s a1 a2 b in
     [+|a1|] * wB + [|a2|] = [+|q|] *  (2 * [|b|]) + [+|r|] /\ 
     0 <= [+|r|] < 2 * [|b|].
\end{verbatim}
The idea of the algorithm is given by the following equation
\begin{verbatim}
  [[WW aH aL]] * wB ^ 2 + [[WW bH bL]] =
    let (q, r) := w_sqrt aH aL in
    let (q1, r1) := w_div2s q bH q in
    [[WW q q1]] ^ 2 + [+|r1|] * wB + [|bL|] - [|q1|] ^ 2 
\end{verbatim}
It indicates that the element {\tt (WW q q1)} is a possible candidate
for the square root. As a matter of fact, because of the condition on
the input, we are sure that the square root is either {\tt (WW q q1)} or
{\tt (WW q q1) -1}. It is the sign of {\tt [+|r1|] * wB + 
[|bL|] - [|q1|] \^{} 2} that indicates in which situation we are. 