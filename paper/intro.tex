

\section{Safe computation and theorem proving}

Recent formalisations such as the four colour theorem~\cite{4color} and the Flyspeck project~\cite{kepler} 
have shown all the benefits one can get from having a formal system where both proving and computing are
possible. In the {\sc Coq} proof assistant~\cite{Coq}, computation is
provided by the logic. A direct application of having computation inside the logic is 
the so-called two-level approach~\cite{boutin}. To illustrate it, 
let us consider the problem of proving the primality of some natural 
numbers.
Suppose that we have defined a predicate {\it prime}: a number is prime 
if it has exactly two divisors, 1 and itself. 
How do we now prove that 17 is prime? The usual approach is to
interactively build a proof object using tactics. Of course, this task can be 
automated by writing an ad-hoc tactic. Still, behind the scene, the system 
will have to build a proof object and the larger the number to be proved
prime is, the larger the proof term will be.
The two-level approach proposes an alternative
strategy in two steps. In the first step, one writes a semi-decision procedure
for the problem in the programming language of {\sc Coq}. In our case, it amounts 
to writing a function {\it test} from natural numbers to booleans such that if the function
returns {\it true} then the number is prime. 
For example, if the natural number
is $n$, the function can check that there is no divisor between 2 and $\sqrt{n}$
by a simple iteration. 
In the second step, one proves that the function meets 
its specification. This means proving for our function {\it test} that
$$
\forall n, \textit{test}\,\, n = \texttt{true} \rightarrow \textit{prime}\,\, n
$$
Note that implication is sufficient for the two-level approach to work.
Proving equivalence would not be of much interest here.
A better way of proving that a number $n$ is not prime is to find externally a factor
$p$ of $n$ and only check internally that $p$ divides $n$.

Once the second step has been completed, for 17 to be certified as prime, 
it is sufficient to prove that the function
{\it test} applied to 17 returns {\tt true}. As the function {\it test} directly
evaluates inside {\sc Coq}, this last proof is simply the reflexivity of equality.
Using the two-level approach, we have just transformed the problem of building a 
large proof object into a conversion problem: showing that $\textit{test}\,\, 17$ is convertible
to {\tt true}.  The size of the proof object is then independent of the number to be proved
prime. 

A recent improvement of the evaluation mechanism~\cite{GreLer} has made the two-level
approach much more attractive.  The evaluation inside {\sc Coq} is now as fast as the bytecode evaluation of
the {\sc Ocaml} language~\cite{Ocaml}. The only restriction when writing programs
inside {\sc Coq} is that programs must be purely functional, i.e. side effects are not allowed,
and must always terminate. This is the price to pay to safely combine proofs
and computations. Obviously, for this approach to be used, 
the {\sc Coq} system should provide efficient functional implementations for the
usual data structures: numbers, strings, vectors, hash tables, \dots 

The contribution of this paper is to propose a purely functional library to compute 
efficiently with large numbers inside {\sc Coq}. The key idea of the library is to 
implement a representation of numbers that accommodates the divide and conquer strategy 
to speed up computation. The paper is organised as follows. In Section~\ref{ZTree}, we present 
the current arithmetic of {\sc Coq} and explain why a new representation of numbers is needed
in order to compute efficiently with large numbers. In Section~\ref{Op}, we give an overview of our new library
based on this new representation.  
In Section~\ref{word}, we detail two possible instantiations of the library.
Finally, Section~\ref{bench} presents an application of the library to the particular
problem of certifying large prime numbers.