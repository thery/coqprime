\section{Implementing base words \label{word}}

The last step to complete our library is to define what the base words are. 
With these words and applying an appropriate number of times our functor
we get the modular arithmetic for the desired size. We have experimented
with two possible implementations for base words.

\subsection{Inductively defined modular arithmetic}

One way to go is to define the arithmetic directly inside {\sc Coq}.
The main benefit is to get an arithmetic library that is expressed entirely
in the logic of {\sc Coq}. The library is portable: no extension of the kernel 
of the system is needed. To define the base arithmetic inside {\sc Coq}, 
we first define an enumerate type. For example, we have for two bits words
\begin{verbatim}
Inductive w2 : Set := OO | OI | IO  | II.
\end{verbatim}
The functions are then defined by simple case analysis. For example,
the exact successor function is defined as
\begin{verbatim}
Definition w2_succ_c x :=
 match x with
 | OO => C0 OI
 | OI => C0 IO
 | IO => C0 II
 | II => C1 OO
 end.
\end{verbatim}
We also need to give the proofs that all functions meets their specification.
These proofs are also done by case analysis. 
Rather than writing by hand all these definitions and proofs, we have
written an {\sc Ocaml} program~\cite{ocaml}. This program takes the word
size as argument and generates the desired base arithmetics with all
the proof. It is a nice application of meta-proving. Unfortunately, the
number of elements of an enumerate type in {\sc Coq} is limited to 
256 elements. This means that the maximum word size of our base arithmetic
is 8.

\subsection{Native modular arithmetic}

Another way to go is to define the modular arithmetic externally and
uses a native arithmetic. We have experimented with the 31 bit native
{\sc Ocaml} arithmetic and a simulated 64 bit arithmetic. The main benefit
is to have a very fast base arithmetic but integrating the library in the
system requires a modification of the kernel. Not all the functions that
we have implemented have their corresponding functions in the native modular
arithmetic, so some native code had to be developed for these functions.
The formal verification of this code has not yet been completed.