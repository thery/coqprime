

\section{Safe computation and prime numbers}

Recent formal developments such as ~\cite{4color,kepler} have shown all the benefits
one can get from having a formal system where both proving and computing are
possible. In the {\sc Coq} proof assistant~\cite{Coq}, computation is
provided by the logic. {\sc Coq} is based on the Calculus of 
Inductive Construction, so the evaluation mechanism is given for free
by the beta reduction rule. 

A direct application of the primitive status of computation is 
the so-called two-level approach~\cite{boutin}. To illustrate it, 
let us consider the problem of proving the primality of some natural 
numbers.
Suppose that we have defined a predicate {\it prime}: a number is prime 
if it has exactly two divisors, one and itself. 
How do we now prove that 17 is prime? The standard approach is to
directly build a proof object using tactics. Of course, this task can be 
automated writing an ad-hoc tactic. Still, behind the scene, the system 
will have to build a proof object and the larger the number to be proved
prime is, the larger the proof term will be.
The two-level approach proposes an alternative
strategy in two steps. In the first step, one defines a function that expresses
the problem in term of pure computation. It can be seen as a semi-decision procedure.
In our case, it amounts in writing a 
function {\tt test} from natural number to boolean such that if the function
returns {\tt true} then the number is prime (correctness is sufficiant, we do
not require completness). 
For example, if the natural number
is $n$, the function can check that there is no divisor between 2 and $n-1$
by a simple iteration. In the second step, one proves that the function meets 
its specification
$$
\forall n, \textit{test}\,\, n = \texttt{true} \rightarrow \textit{prime}\,\, n
$$
So our semi-decision procedure is correct.
Now to give a proof that 17 is prime, it is sufficient to prove that the function
{\tt test} applies to 17 returns {\tt true}. As the function {\it test} directly
evaluates inside {\sc Coq}, this last proof is simply the reflexivity of equality.
Using the two-level approach, we have just transfered the problem of building a 
large proof object into a conversion problem: showing that $test\,\, 17$ is convertible
to {\tt true}.  The size of the proof object is then independent of the number to be proved
prime. Recent progress in the evaluation mechanism~\cite{GreLer} has also made this
approach attractive from the point of view of efficiency.
If we want to generalize the use of the two-level approach it is important
to provide efficient libraries to developer. In particular, efficient libraries
over numbers.
 
The key idea of our library is to implement a representation of numbers that accommodates the divide and
conquer strategy to speed up computation. The paper is organized as follows. 
In Section~\ref{ZTree}, we confront the standard arithmetic of {\sc Coq} with
our representation of numbers. In Section~\ref{Op}, we give an overview of the library.  
In Section~\ref{word}, we detail two possible instantiations of our library.
Finally, Section~\ref{bench} presents some tests that validate our approach.
 
