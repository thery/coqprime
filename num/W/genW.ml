
let digits = ref 2

let usage_basename = 
  "  -o basename : set the base name of each files to [basename], default is Wn where n is the number of digits \n"

let usage_compare = 
  "  -compare : generate files containing the comparison function and its proof\n"

let usage_opp = 
  "  -opp : generate files containing the opposite functions and there proofs\n"

let usage_add = 
  "  -add : generate files containing the addition functions and there proofs\n"

let usage_sub = 
  "  -sub : generate files containing the subtraction functions and there proofs\n"

let usage_mul = 
  "  -mul : generate files containing the multiplication functions and there proofs\n"

let usage_div = 
  "  -div : generate files containing the division function and its proofs\n"

let usage_lift = 
  "  -lift : generate files containing the lift function and its proofs\n"
let usage_op = 
  "  -op : generate files containing the record of operators and specifications \n"
let usage =  
  "Usage : genW [option] digits\n"^
  " Options are \n" ^
  usage_basename ^
  " if some of the following option are used only the files generated by the options are generated, by default all files are generated\n" ^
  usage_compare ^
  usage_opp ^
  usage_add ^
  usage_sub ^
  usage_mul ^
  usage_div ^
  usage_lift ^
  usage_op
  

let setsize s =
  let n = int_of_string s in
  if n < 2 || n > 12 then begin
    print_string "number of digits should be between 2 and 11\n"; 
    exit 1
  end;
  digits := n

let defaultname = ref true

let basename = ref ""

let setname s = 
  basename := s;
  defaultname := false

let all = ref true
let compare = ref false
let opp = ref false
let add = ref false
let sub = ref false
let mul = ref false
let div = ref false
let lift = ref false
let op = ref false

let set_opt opt = 
  Arg.Unit (fun _ -> all := false; opt := true)
(* ** Parse the arguments ** *)

let _ = 
  Arg.parse
    [("-o",Arg.String setname, "");
     ("-compare",set_opt compare  , "");
     ("-opp",set_opt opp , "");
     ("-add",set_opt add , "");
     ("-sub",set_opt sub , "");
     ("-mul",set_opt mul , "");
     ("-div",set_opt div , "");
     ("-lift",set_opt lift , "");
     ("-op",set_opt op , "");
   ] 
    setsize 
    usage

(* ** compute the base and set basename ** *)

let (base, fd) =     
  let base = 1 lsl !digits in
  let outname = 
    if !defaultname then (basename := "W"^(string_of_int !digits);!basename)
    else !basename in
  (base, outname) 

let print = Format.print_string
let println s = print s;print "\n"
let printi = Format.print_int
let print_title s =
  println "";
  print "(* ** ";print s;println " ** *)";
  println ""

let wt = "w"^(string_of_int !digits)

let print_wt () = print wt;;

let print_def f args =
  print "Definition ";print f;
  if args != "" then (print " ";print args);
  println " :="

let print_spec f args concl =
  print "Lemma "; print f;print "_spec : ";
  if String.length args <> 0 then (print "forall ";print args;print ", ");
  print concl; println ".";
  println "Proof"

let print_lemma f args concl =
  print "Lemma "; print f;print "_spec : ";
  if String.length args <> 0 then (print "forall ";print args;print ", ");
  print concl; println ".";
  println "Proof."

let print_fun args = print "fun ";print args;println" =>"

let print_match args =
  print " match ";print args;println " with"

let print_match_dep arg dep =
  print " match ";print arg;
  print " as ";print arg;print " return ";print dep; println " with"

let string_w n =
  let s = ref "" in
  let n = ref n in
  for i = 1 to !digits do
    let d = if !n mod 2 = 0 then "O" else "I" in
    s := d^(!s);
    n := !n/2
  done;
  !s

let print_w n = print (string_w n)

let print_c n =
  if n < 0 then (print "C1 ";print_w (base + n))
  else 
    if n/base = 0 then (print "C0 ";print_w n)
    else begin 
      assert (n < 2*base - 1);
      print "C1 ";print_w n
    end
    
let rec print_pos_s s n =
  if n <= 1 then print s
  else begin
    if n mod 2 = 0 then print "(xO "
    else print "(xI ";
    print_pos_s s (n/2);print ")"
  end

let print_pos = print_pos_s "xH"

let print_notation nota f x =
  print "Notation \"";print nota; print"\" := (";
   print f; print " "; print x;print ")  (at level 0, x at level 99) : ";
   println (wt^"_scope.")

let open_scope () = println ("Open Local Scope "^wt^"_scope.")

let start_file post =
  let outname = !basename^"_"^post^".v" in
  let fd = 
    try 
      Unix.openfile outname [Unix.O_WRONLY;Unix.O_CREAT;Unix.O_TRUNC] 0o640 
    with _ -> 
      print_string ("can not open file "^outname^"\n"); 
      exit 1  in
  let out = Unix.out_channel_of_descr fd in
  set_binary_mode_out out false;
  Format.set_formatter_out_channel out;
  out
  
let end_file out = 
  Format.print_flush ();
  Format.set_formatter_out_channel stdout;
  let fd = Unix.descr_of_out_channel out in
  Unix.close fd

let print_require b r = 
  println "Require Import ZArith.";
  println "Open Local Scope Z_scope.";  
  print "Require Import ";print !basename;println "_basic.";
  if b then 
    (print "Require Import ";print !basename;println "_basic_spec.");
  open_scope ();
  if String.length r <> 0 then
    (print "Require Import ";print !basename;print ("_"^r);println ".");
  println "";
  println ""
  
(* ** Basic definitions ** *)

let w_digits = wt^"_digits"
let w_B = wt^"_B"
let w_to_Z = wt^"_to_Z"
let w_of_pos = wt^"_of_pos"
let w_of_N = wt^"_of_N"
let w_0 = wt^"_0"
let w_1 = wt^"_1"
let w_Bm1 = wt^"_Bm1"
let w_WW = wt^"_WW"
let w_CW = wt^"_CW"

let print_basic () =
  let out = start_file "basic" in 
  println "Require Import ZArith.";
  println "Require Export Basic_type.";
  println "";
  println "";
  println "Open Local Scope Z_scope.";
  println "";

  print  ("Inductive "^wt^" : Set :=");
  for i = 0 to base - 1 do
    println "";
    print " | "; print_w i;print " : ";print_wt()
  done; println ".";
  println "";

  print_title "Conversion functions with Z, N and positive";

  print "Definition ";print w_B; print " := ";printi base; println ".";
  
  print_def w_to_Z "x";
  print_match "x";
  for i = 0 to base - 1 do
    print  " | ";print_w i;print " => ";printi i;println "";
  done;
  println  " end.";
  println "";

  print_def w_of_pos "p";
  print_match "p";
  for i = 1 to base - 1 do
    print " | ";print_pos i;print " => (N0, ";print_w i;println ")"
  done;
  for i = 0 to base - 1 do
    print " | ";print_pos_s "p" (i+base);
         print " => (Npos p, ";print_w i;println ")"
  done;
  println  " end.";
  println "";

  print_def w_of_N "n";
  print_match "n";
  print    " | N0 => (N0, ";print_w 0;println ")";
  println (" | Npos p => "^w_of_pos^" p");
  println  " end.";
  println "";

  print_title "Constructors for the next level";

  print_def w_WW "xh xl";
  print_match "xh, xl";
  print    " | ";print_w 0;print ", ";print_w 0;println " => W0";
  println  " | _, _ => WW xh xl";
  println "end.";
  println "";
  
  print_def w_CW "ch xl";
  println "Eval compute in";
  print_match "ch";
  println (" | C0 xh => C0 ("^w_WW^" xh xl)");
  println (" | C1 xh => C1 ("^w_WW^" xh xl)");
  println " end.";
  println "";
  print_notation "[| x |]" w_to_Z "x";
  print_notation "[+| x |]" ("interp_carry 1 "^w_B^" "^w_to_Z) "x";
  print_notation "[-| x |]" ("interp_carry (-1) "^w_B^" "^w_to_Z) "x";
  print_notation "[|| x ||]" ("zn2z_to_Z "^w_B^" "^w_to_Z) "x";

  end_file out;

  let out = start_file "basic_spec" in
  print_require false "";

  print_title "Proof that the basic functions are correct";

  let typ = "0 <= [|x|] < "^w_B in
  print_spec w_to_Z "x" typ;
  print_fun "x";
  print_match_dep "x" typ;
  print " | ";print_w 0;println " => conj (Zle_refl 0) (refl_equal Lt)";
  for x = 1 to base - 1 do
    print " | ";print_w x;print " => conj (Zle_0_pos ";
      printi x; println ") (refl_equal Lt)"
  done;
  println "end.";
  println "";

  let typ p = 
    "Zpos "^p^" = "^w_B^"*(Z_of_N (fst ("^w_of_pos^" "^p^
                               "))) + [|snd ("^w_of_pos^" "^p^")|]" in
  let rec print_m space i mkp =
    let pi = "p"^(string_of_int i) in
    let pi1 = "p"^(string_of_int (i+1)) in
    let p = mkp pi in
    if i = !digits then (print space;print ("refl_equal (Zpos "^p^")"))
    else
      let spacei1 = space^"   " in
      print space; print_match_dep pi (typ p);
      print space;print " | xH => "; println ("refl_equal (Zpos "^
                                                         (mkp "xH")^")");
      print space;print " | xO ";print pi1;println " =>";
      print_m spacei1 (i+1) (fun pi -> mkp ("(xO "^pi^")")); println "";
      print space;print " | xI ";print pi1;println " =>";
      print_m spacei1 (i+1) (fun pi -> mkp ("(xI "^pi^")")); println "";
      print space;print " end" 
  in
  print_spec w_of_pos "p" 
    ("Zpos p = (Z_of_N (fst ("^w_of_pos^" p)))*"^w_B^" + [|snd ("^
                                                     w_of_pos^" p)|]");
  print_fun "p0";
  println (" eq_ind_r (fun z : Z => Zpos p0 = z + [|snd ("^w_of_pos^" p0)|])");

  print_m "" 0 (fun p -> p);
  println (" (Zmult_comm (Z_of_N (fst ("^w_of_pos^" p0))) "^w_B^").");
  println "";

  print_spec w_0 "" ("[|"^(string_w 0)^"|] = 0");
  println "(refl_equal 0).";
  println "";

  print_spec w_1 "" ("[|"^(string_w 1)^"|] = 1");
  println "(refl_equal 1).";
  println "";
 
  print_spec w_Bm1 "" ("[|"^(string_w (base - 1))^"|] = "^w_B^" - 1");
  print "(refl_equal ";printi (base-1);println ").";
  println "";
		     
  let typ h l = 
    "[||"^w_WW^" "^h^" "^l^"||] = [|"^h^"|] * "^w_B^" + [|"^l^"|]" in
  print_spec w_WW "h l" (typ "h" "l");
  print_fun "h l";
  print_match_dep "h" (typ "h" "l");
  print " | ";print_w 0;println " => ";
  print "   ";print_match_dep "l" (typ (string_w 0) "l");
  for l = 0 to base - 1 do 
    print "    | ";print_w l;print " => refl_equal ";printi l;
    println ""
  done;
  println "    end";
  for i = 1 to base - 1 do
    print " | ";print_w i;print " => refl_equal ([||";
    print (w_WW^" ");print_w i;println " l||])"
  done;
  println " end.";
  println "";
    
  print_lemma w_CW "sign c l" 
    ("interp_carry sign ("^w_B^"*"^w_B^") (zn2z_to_Z "^w_B^" "^
     w_to_Z^") ("^w_CW^" c l) = (interp_carry sign "^w_B^" "^w_to_Z^
      " c)*"^w_B^" + [|l|]");
  print "intros sign c l;case c;intro h;simpl;fold (";print w_WW;
  print " h l); rewrite ";print w_WW;print "_spec;";
  println ("unfold "^w_B^"; ring.");
  println "Qed.";
  println "";
      
  end_file out

(* Comparison *)

let w_compare = wt^"_compare"

let print_compare () = 
  let out = start_file "compare" in
  print_require false "";

  print_title "Comparison";
  
  print_def w_compare "x y";
  print_match "x";

  for x = 0 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match "y";
    for y = 0 to x - 1 do
      print "    | ";print_w y; println " => Gt"
    done;
    print "    | ";print_w x; println " => Eq";
    if x < base - 1 then println "    | _ => Lt end"
    else println "    end"
  done;
  println " end.";
  println "";
  end_file out;
  
  let out = start_file "compare_spec" in
  print_require true "compare";

  let typ x y =
     "match "^w_compare^" "^x^" "^y^" return Prop with "^
     " | Eq => [|"^x^"|] = [|"^y^"|]"^
     " | Lt => [|"^x^"|] < [|"^y^"|]"^
     " | Gt => [|"^x^"|] > [|"^y^"|] end" in
  print_spec w_compare "x y" (typ "x" "y");
  print_fun "x y";
  print " let typ x y := ";print (typ "x" "y");println " in";
  print_match_dep "x" ("typ x y");
  for x = 0 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match_dep "y" ("typ "^(string_w x)^" y");
    for y = 0 to x - 1 do
      print "    | ";print_w y; println " => refl_equal Gt"
    done;
    print "    | ";print_w x; print " => refl_equal ";printi x;println "";
    if x < base - 1 then println "    | _ => refl_equal Lt";
    println "    end"
  done;
  println " end.";
  println "";
  end_file out
  

let w_opp_c = wt^"_opp_c"
let w_opp_carry = wt^"_opp_carry"

let print_opp () =
  let out = start_file "opp" in
  print_require false "";
  print_title "Opposites";
  
  print_def w_opp_c "x";
  print_match "x";
  print " | ";print_w 0;print " => C0 "; print_w 0;println "";
  for i = 1 to base - 1 do
    print " | ";print_w i;print " => C1 "; print_w (base - i);println ""
  done;
  println  " end.";
  println "";
  
  print_def w_opp_carry "x";
  print_match "x";
  for i = 0 to base - 1 do
    print " | ";print_w i;print " => "; print_w (base - i - 1);println ""
  done;
  println  " end.";
  println "";
  end_file out;
 
  let out = start_file "opp_spec" in
  print_require true "opp";
  let typ x = "[-|"^w_opp_c^" x|] = -[|"^x^"|]" in
  print_spec w_opp_c "x" (typ "x");
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal (-";printi x;println ")"
  done;
  println " end.";
  println "";

  let typ x = "[|"^w_opp_carry^" "^x^"|] = "^w_B^" - [|"^x^"|] - 1" in
  print_spec w_opp_carry "x" (typ "x");
  print_fun "x";
  print_match_dep "x" (typ "x"); 
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal ";
    printi (base - x - 1);println ""
  done;
  println " end.";
  println "";
  end_file out

let w_succ_c = wt^"_succ_c"
let w_carry_succ_c = wt^"_carry_succ_c"
let w_add_c = wt^"_add_c" 
let w_add_carry_c = wt^"_add_carry_c"
let w_add = wt^"_add"

let print_add () =
  let out = start_file "add" in
  print_require false "";
  print_title "Additions";

  print_def w_succ_c "x";
  print_match "x";
  for i = 0 to base - 1 do
    print  " | ";print_w i;print " => ";print_c (i+1);println "";
  done;
  println  " end.";
  println "";

  print_def w_carry_succ_c "cx";
  println " Eval compute in";
  print_match "cx";
  print    " | C0 x => "; print w_succ_c;println " x";
  println  " | C1 x => ";
  print "   ";print_match "x";
  for x = 0 to base - 1 do 
    print "    | ";print_w x;print " => C1 ";print_w (x+1);println ""
  done;
  println "    end";
  println " end.";
  println "";
  
  print_def w_add_c "x y";
  print_match "x";
  print     " | ";print_w 0;println " => C0 y";
  for x = 1 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match "y";
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => ";
      print_c (x+y);println "";
    done;
    println "    end"
  done;
  println  " end.";
  println "";

  print_def w_add_carry_c "x y";
  print_match "x";
  for x = 0 to base - 2 do
    print " | ";print_w x; println " => ";
    print "   ";print_match "y";
    for y = 0 to base - 1 do
      print "    | ";print_w y; print " => "; print_c (x+y+1);println ""
    done;
    println "    end";
  done;
  print    " | ";print_w (base-1);println " => C1 y";
  println  " end.";
  println "";

  print_def w_add "x y";
  print_match "x";
  print     " | ";print_w 0;println " => y";
  for x = 1 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match "y";
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => ";
      print_w (x+y);println "";
    done;
    println "    end"
  done;
  println  " end.";
  println "";


  end_file out;
  
  let out = start_file "succ_c_spec" in
  print_require false "add";

  let typ x = "[+|"^w_succ_c^" "^x^"|] = [|"^x^"|] + 1" in
  print_spec w_succ_c "x" (typ "x");
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal (";printi x;println "+1)"
  done;
  println " end.";
  println "";

  let hyp c = "[+|"^c^"|] <= "^w_B^" + ("^w_B^" - 2)" in
  let concl c = "[+|"^w_carry_succ_c^" "^c^"|] = [+|"^c^"|] + 1" in
  let typ c = (hyp c)^" -> "^(concl c) in
  print_spec w_carry_succ_c "c" (typ "c");
  print_fun "c";
  print_match_dep "c" (typ "c");
  print " | C0 x => fun (H:";print (hyp "C0 x");print ")=> ";
    print w_succ_c;println "_spec x";
  println " | C1 x =>";
  print   "   ";print_match_dep "x" (typ "(C1 x)");
  for x = 0 to base - 2 do
    print "    | ";print_w x;
    print " => fun (H:";print (hyp ("C1 "^(string_w x)));
    print ") => refl_equal ";printi (base+x+1); println ""
  done;
  print "    | ";print_w (base - 1);println " =>";
  print "      fun (H:";print (hyp ("C1 "^(string_w (base-1))));
                                                       println ") =>";
  println "        False_ind";
    print "          (";print (concl ("(C1 "^(string_w (base-1))^")"));
                                                              println ")";
  println "          (H (refl_equal Gt))";
  println "    end";
  println " end.";
  println "";
  
  end_file out;
    
  let out = start_file "add_c_spec" in
  print_require false "add";

  let typ x y = "[+|"^w_add_c^" "^x^" "^y^"|] = [|"^x^"|] + [|"^y^"|]" in
  print_spec w_add_c "x y" (typ "x" "y");
  print_fun "x y";
  print_match_dep "x" (typ "x" "y"); 
  print     " | ";print_w 0;println " => refl_equal [|y|]";
  for x = 1 to base - 1 do
    print " | ";print_w x; println " => ";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => refl_equal (";
                                                    printi (x+y);println ")"
    done;
    println "    end"
  done;
  println  " end.";
  println "";
  
  end_file out;
    
  let out = start_file "add_carry_c_spec" in
  print_require false "add";


  let typ x y = 
    "[+|"^w_add_carry_c^" "^x^" "^y^"|] = [|"^x^"|] + [|"^y^"|] + 1" in
  print_spec w_add_carry_c "x y" (typ "x" "y");
  print_fun "x y";
  print_match_dep "x" (typ "x" "y"); 
  for x = 0 to base - 1 do
    print " | ";print_w x; println " => ";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => refl_equal (";
                                                    printi (x+y+1);println ")"
    done;
    println "    end"
  done;
  println  " end.";
  println "";
 
  end_file out;

  let out = start_file "add_spec" in
  print_require false "add";

  let typ x y =
    "[|"^w_add^" "^x^" "^y^"|] = ([|"^x^"|] + [|"^y^"|]) mod "^w_B in
  print_spec w_add "x y" (typ "x" "y");
  print_fun "x y";
  print_match_dep "x" (typ "x" "y"); 
  for x = 0 to base - 1 do
    print " | ";print_w x; println " => ";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => refl_equal (";
                                           printi ((x+y) mod base);println ")"
    done;
    println "    end"
  done;
  println  " end.";
  println "";

  end_file out

let w_pred_c = wt^"_pred_c"
let w_sub_c = wt^"_sub_c"
let w_sub_carry_c = wt^"_sub_carry_c"
let w_sub = wt^"_sub"

let print_sub () =
  let out = start_file "sub" in
  print_require false "";
  print_title "Subtractions";
  
  print_def w_pred_c "x";
  print_match "x";
  for i = 0 to base - 1 do
    print    " | "; print_w i;print " => ";print_c (i-1);println ""
  done;
  println  " end.";
  println "";
  
  print_def w_sub_c "x y";
  print_match "y";
  print    " | ";print_w 0;println " => C0 x";
  for y = 1 to base - 1 do
    print " | ";print_w y; println " => ";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print    "    | ";print_w x; print " => "; print_c (x-y);println ""
    done;
    println "    end"
  done;
  println  " end.";
  println "";
  
  print_def w_sub_carry_c "x y";
  print_match "y";
  for y = 0 to base - 2 do
    print " | ";print_w y; println " =>";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print    "    | ";print_w x; print " => "; print_c (x-y-1);println ""
    done;
    println "    end"
  done;
  print    " | ";print_w (base-1);println " => C1 x";
  println  " end.";
  println "";

  print_def w_sub "x y";
  print_match "y";
  print    " | ";print_w 0;println " => x";
  for y = 1 to base - 1 do
    print " | ";print_w y; println " =>";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print    "    | ";print_w x; print " => ";
      let r = x - y in
      print_w (if r < 0 then r+base else r);
      println ""
    done;
    println "    end"
  done;
  println  " end.";
  println "";
  
  end_file out;
 
  let out = start_file "pred_c_spec" in
  print_require false "sub";

  let typ x = " [-|"^w_pred_c^" "^x^"|] = [|"^x^"|] - 1" in
  print_spec w_pred_c "x" (typ "x");
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal (";printi(x-1);println ")"
  done;
  println " end.";
  println "";

  end_file out;

  let out = start_file "sub_c_spec" in
  print_require false "sub";

  let typ x y = "[-|"^w_sub_c^" "^x^" "^y^"|] = [|"^x^"|] - [|"^y^"|]" in
  print_spec w_sub_c "x y" (typ "x" "y");
  print_fun "x y";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      print "    | ";print_w x;print " => refl_equal (";
                                         printi (x-y);println ")"
    done;
    println "   end";
  done;
  println " end.";
  println "";

  end_file out;

  let out = start_file "sub_carry_c_spec" in
  print_require false "sub";

  let typ x y = 
    "[-|"^w_sub_carry_c^" "^x^" "^y^"|] = [|"^x^"|] - [|"^y^"|] - 1" in
  print_spec w_sub_carry_c "x y" (typ "x" "y");
  print_fun "x y";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      print "    | ";print_w x;print " => refl_equal (";
                                         printi (x-y-1);println ")"
    done;
    println "   end";
  done;
  println " end.";
  println "";

  end_file out;

  let out = start_file "sub_spec" in
  print_require false "sub";

  let typ x y =
    "[|"^w_sub^" "^x^" "^y^"|] = ([|"^x^"|] - [|"^y^"|]) mod "^w_B in
  print_spec w_sub "x y" (typ "x" "y");
  print_fun "x y";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      let r = x - y in
      print "    | ";print_w x;print " => refl_equal (";
                              printi (if r < 0 then r+base else r);println ")"
    done;
    println "   end";
  done;
  println " end.";
  println "";

  end_file out

let w_mul_c = wt^"_mul_c"
let w_mul = wt^"_mul"
let w_square_c = wt^"_square_c"

let print_mul () =
  let out = start_file "mul" in
  print_require false "";
  print_title "Multiplcations";

  print_def w_mul_c "x y";
  print_match "x";
  print     " | ";print_w 0; print " => W0";println "";
  print     " | ";print_w 1; print " => WW ";print_w 0;println " y";
  for x = 2 to base - 1 do
    print " | ";print_w x; println   " =>";
    print "   ";print_match "y";
    print "    | ";print_w 0;println " => W0";
    print "    | ";print_w 1; print " => WW ";print_w 0;
          print " ";print_w x; println "";
    for y = 2 to base - 1 do
      let prod = x * y in
      print "    | ";print_w y; print " => WW ";
      print_w (prod/base);print " ";print_w prod; println ""
    done;
    println "    end"
  done;
  println  " end.";
  println "";

  print_def w_mul "x y";
  print_match (w_mul_c^" x y");
  print   " | W0 => ";print_w 0;println "";
  println " | WW _ l => l";
  println " end.";
  println "";

  print_def w_square_c "x";
  print_match "x";
  print " | ";print_w 0;println " => W0";
  for x = 1 to base - 1 do
    let xx= x*x in 
    print " | ";print_w x;print " => WW ";
    print_w (xx/base);print " ";print_w xx; println ""
  done;
  println " end.";
  println "";

  end_file out;
 
  let out = start_file "mul_c_spec" in
  print_require false "mul";
  
  let typ x y = 
     "[||"^w_mul_c^" "^x^" "^y^"||] = [|"^x^"|] * [|"^y^"|]" in
  print_spec w_mul_c "x y" (typ "x" "y");
  print_fun "x y";
  print_match_dep "x" (typ "x" "y");
  print " | ";print_w 0;println " => refl_equal 0";
  for x = 1 to base - 1 do 
    print " | ";print_w x;println " =>";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print "    | ";print_w y; print " => refl_equal ";
      printi (x*y);println ""
    done;
    println "    end"
  done;
  println " end.";
  println "";
   
  end_file out;
 
  let out = start_file "mul_spec" in
  print_require true "mul";
  println "Require Import ZDivModAux.";
  print "Require Import ";print !basename;println "_mul_c_spec.";
  println "Open Local Scope Z_scope.";
  println "";
  println "";

  let typ x y = 
    "[|"^w_mul^" "^x^" "^y^"|] = ([|"^x^"|] * [|"^y^"|]) mod "^w_B in
  print_lemma w_mul "x y" (typ "x" "y");
  println (" assert (H1: 0 < "^w_B^"). exact (refl_equal Lt).");
  println (" assert (H2: "^w_B^" > 0). exact (refl_equal Gt).");
  println (" unfold "^w_mul^";intros x y.");
  println (" assert (H := "^w_mul_c^"_spec x y); destruct ("^w_mul_c^" x y).");
  println (" rewrite <- H; reflexivity.");
  println (" rewrite <- H; simpl.");
  println (" rewrite Zmod_plus;trivial.");
  println (" rewrite Zmod_mult;trivial.");
  println (" rewrite Z_mod_same;trivial.");
  println (" rewrite Zmult_0_r; rewrite (Zmod_def_small 0).");
  println (" simpl; rewrite Zmod_mod;trivial.");
  println (" rewrite Zmod_def_small;trivial.");
  println (" apply "^w_to_Z^"_spec.");
  println (" split;[intro Heq;discriminate Heq | exact (refl_equal Lt)].");
  println ("Qed.");
  println "";
 
  end_file out;

  let out = start_file "square_c_spec" in
  print_require false "mul";
 
  let typ x = "[|| "^w_square_c^" "^x^"||] = [|"^x^"|] * [|"^x^"|]" in
  print_spec w_square_c "x" (typ "x");
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal ";printi (x*x);println ""
  done;
  println " end.";
  println "";

  end_file out

let w_div_wB = wt^"_div_wB"
let w_div21 = wt^"_div21"
  
 let print_div () =
  let out = start_file "div" in
  print_require false "";
  print "Require Import ";print !basename;println "_compare.";
  print "Require Import ";print !basename;println "_add.";
  print "Require Import ";print !basename;println "_sub."; 
  print_title "Division";

  print_def w_div_wB "x y";
  print_match "y";
  for y = 0 to base/2 - 1 do
    print " | ";print_w y;print " => (C0 ";print_w 0; 
                                      print ", ";print_w 0;println ")"; 
  done;
  for y = base/2 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print "    | ";print_w x;print " => (";
      let xB = x*base in 
      let q, r = xB / y, xB mod y in
      print_c q; print ", ";print_w r;println ")";
    done;
    println "   end";
  done;
  println " end.";
  println "";
    
  print_def w_div21 "a1 a2 b";
  println (" let (q,s) := "^w_div_wB^" a1 b in");
  println (" match "^w_add_c^" s a2 with");
  println (" | C0 r =>");
  println ("   match "^w_compare^" r b with");
  println ("   | Eq => ("^w_carry_succ_c^" q, "^(string_w 0)^")");
  println ("   | Lt => (q, r)");
  println ("   | Gt => ("^w_carry_succ_c^" q, "^w_sub^" r b)");
  println ("   end");
  println (" | C1 r =>");
  println ("   let q := "^w_carry_succ_c^" q in");
  println ("   let r' := "^w_sub^" r b in");
  println ("   match "^w_compare^" r' b with");
  println ("   | Eq => ("^w_carry_succ_c^" q, "^(string_w 0)^")");
  println ("   | Lt => (q, r')");
  println ("   | Gt => ("^w_carry_succ_c^" q, "^w_sub^" r' b)");
  println ("   end");
  println (" end.");
  println "";

  end_file out;
 
  let out = start_file "div_wB_spec" in
  print_require false "div";

  let hyp y =  w_B^"/2 <= [|"^y^"|]" in
  let concl x y = 
    "match "^w_div_wB^" "^x^" "^y^" return Prop with " ^
    "(q,r) => [|"^x^"|] * "^w_B^" = [+|q|]*[|"^y^"|] + [|r|] /\\ "^
    "[|r|] < [|"^y^"|] end" in
  let typ x y =  (hyp y)^" -> "^(concl x y) in
  print_spec w_div_wB "x y" (typ "x" "y");
  print_fun "x y";
  print_match_dep "y" (typ "x" "y"); 
  for y = 0 to base/2 - 1 do
    print " | ";print_w y; println " =>";
    print "   fun (H:";print (hyp (string_w y));println ") => ";
    println "     False_ind";
    print "       (";print (concl "x" (string_w y));println ")";
    println "       (H (refl_equal Gt))"
  done;
  for y = base/2 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   fun (H:";print (hyp (string_w y));println ") => ";
    print "    ";print_match_dep "x" (concl "x" (string_w y));
    for x = 0 to base - 1 do
      print "     | ";print_w x;print " => conj (refl_equal ";
      printi (x*base);println ") (refl_equal Lt)"
    done;
    println "     end";
  done; 
  println " end.";
  println "";

  end_file out;
 
  let out = start_file "div_spec" in
  print_require true "div";
  print "Require Import ";print !basename;println "_compare.";
  print "Require Import ";print !basename;println "_add.";
  print "Require Import ";print !basename;println "_sub."; 
  print "Require Import ";print !basename;println "_compare_spec.";
  print "Require Import ";print !basename;println "_succ_c_spec.";
  print "Require Import ";print !basename;println "_add_c_spec.";
  print "Require Import ";print !basename;println "_sub_spec."; 
  print "Require Import ";print !basename;println "_div_wB_spec."; 
  println "Require Import ZDivModAux.";
  println "Open Local Scope Z_scope.";
 
  println ("Lemma "^w_div21^"_spec : forall a1 a2 b,");
  println ("     "^w_B^"/2 <= [|b|] ->");
  println ("     let (q,r) := "^w_div21^" a1 a2 b in");
  println ("     [|a1|] *"^w_B^
           "+ [|a2|] = [+|q|] *  [|b|] + [|r|] /\\ 0 <= [|r|] < [|b|].");
  println ("Proof.");
  println (" intros a1 a2 b Hle.");
  println (" unfold "^w_div21^".");
  println (" assert (H := "^w_div_wB^"_spec a1 b Hle);destruct ("^
           w_div_wB^" a1 b).");
  println (" destruct H as (H,Hltb).");
  println (" assert (Hlt:0<[|b|]).");  
  println ("  unfold "^w_B^",Zdiv in Hle;simpl in Hle;omega.");
  println (" assert (Hle_a1 : [|a1|]*"^w_B^" <= (("^w_B^" + ("^w_B^
           " - 2)) * [|b|])).");
  println ("  replace (("^w_B^" + ("^w_B^" - 2)) * [|b|]) with (("^
           w_B^" -1)*(2*[|b|])).");
  println ("  apply Zmult_le_compat.");
  println ("  assert (H1 := "^w_to_Z^"_spec a1);omega.");
  println ("  change "^w_B^" with (2*("^w_B^"/2)).");
  println ("  apply Zmult_le_compat_l;trivial."); 
  println ("  intro H1;discriminate H1.");
  println ("  destruct("^w_to_Z^"_spec a1);trivial.");
  println ("  intro H1;discriminate H1.");
  println ("  ring.");
  println (" assert ([+|c|] <= "^w_B^" + ("^w_B^" -2)).");
  println ("  apply Zmult_le_reg_r with [|b|]."); 
  println ("  omega.");
  println ("  apply Zplus_le_reg_r with [|w|].");
  println ("  rewrite <- H.");
  println ("  apply Zle_trans with (("^w_B^" + ("^w_B^" - 2)) * [|b|]).");
  println ("  trivial.");
  println ("  assert (H1 := "^w_to_Z^"_spec w);omega.");
  println (" assert (H1 := "^w_add_c^"_spec w a2);destruct ("^
           w_add_c^" w a2) as [r|r].");
  println (" assert (H2 := "^w_compare^
           "_spec r b);destruct ("^w_compare^" r b).");
  println (" rewrite ("^w_carry_succ_c^"_spec c H0);rewrite H.");
  println (" rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1;rewrite H2.");
  println (" simpl;split;[ring|omega]."); 
  println (" rewrite H;rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1.");
  println (" split;[trivial| assert (H3 := "^w_to_Z^"_spec r);omega].");
  println (" rewrite ("^w_carry_succ_c^"_spec c H0);rewrite H.");
  println (" rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1.");
  println (" rewrite ("^w_sub^"_spec r b).");
  println (" assert (H3 := "^w_to_Z^"_spec r);assert (H4 := "^w_to_Z^
           "_spec b).");
  println (" change "^w_B^" with (2*("^w_B^"/2)) in H3.");
  println (" rewrite Zmod_def_small.");
  println (" simpl;split;[ring|omega].  omega.");
  println (" unfold interp_carry in H1;rewrite Zmult_1_l in H1.");
  println (" assert ([|r|] < [|b|]).");
  println ("  apply  Zplus_lt_reg_l with "^w_B^"."); 
  println ("  rewrite H1;rewrite Zplus_comm;apply Zplus_lt_compat;trivial.");
  println ("  assert (H2 := "^w_to_Z^"_spec a2);omega.");
  println (" assert ([|"^w_sub^" r b|] = "^w_B^" + [|r|] - [|b|]).");
  println ("  rewrite "^w_sub^"_spec.");
  println ("  replace (([|r|] - [|b|]) mod "^w_B^") with (("^
           w_B^" + ([|r|] - [|b|])) mod "^w_B^").");
  println ("  rewrite Zmod_def_small. ring.");
  println ("  assert (H3 := "^w_to_Z^"_spec b); assert (H4 := "^
           w_to_Z^"_spec r);omega.");
  println ("  rewrite Zmod_plus. rewrite Z_mod_same. simpl;apply Zmod_mod.");
  println 
    ("  exact (refl_equal Lt). exact (refl_equal Gt). exact (refl_equal Lt).");
  println (" rewrite H;rewrite <- Zplus_assoc;rewrite <- H1.");
  println (" assert (H4 := "^w_compare^"_spec ("^w_sub^" r b) b);");
  println ("   destruct ("^w_compare^" ("^w_sub^" r b) b).");
  println (" split;[idtac|simpl;auto with zarith].");
  println (" rewrite "^w_0^"_spec;rewrite Zplus_0_r.");
  println (" rewrite "^w_carry_succ_c^"_spec.");
  println (" rewrite ("^w_carry_succ_c^"_spec c H0).");
  println (" replace ("^w_B^" + [|r|]) with ([|b|] + [|b|]).");
  println (" ring. rewrite H4 in H3;pattern [|b|] at 1;rewrite H3;ring.");
  println (" rewrite ("^w_carry_succ_c^"_spec c H0).");
  println (" destruct (Zle_lt_or_eq _ _ H0). omega.");
  println (" rewrite H5 in H.");
  println (" assert (H6:= "^w_to_Z^"_spec r);assert (H7:= "^w_to_Z^
           "_spec a2);");
  println (" assert (H8:= "^w_to_Z^"_spec w);omega.");
  println (" split.");
  println (" rewrite H3;rewrite ("^w_carry_succ_c^"_spec c H0);ring.");
  println (" assert (H5 := "^w_to_Z^"_spec ("^w_sub^" r b));omega.");
  println (" rewrite "^w_carry_succ_c^"_spec.");
  println (" rewrite ("^w_carry_succ_c^"_spec c H0).");
  println (" rewrite "^w_sub^"_spec.");
  println (" rewrite Zmod_def_small.");
  println (" split. rewrite H3;ring.");  
  println (" assert (H5 := "^w_to_Z^"_spec ("^w_sub^" r b)).");
  println (" change "^w_B^" with (2*("^w_B^"/2)) in H5;omega.");
  println (" omega.");
  println (" rewrite ("^w_carry_succ_c^"_spec c H0).");
  println (" destruct (Zle_lt_or_eq _ _ H0). omega.");
  println (" rewrite H5 in H.");
  println (" assert (H6:= "^w_to_Z^"_spec r);assert (H7:= "^
           w_to_Z^"_spec a2);");
  println (" assert (H8:= "^w_to_Z^"_spec w);omega.");
  println ("Qed.");
  println "";

  end_file out


(*
Lemma spec_div21 : forall a1 a2 b,
     w2_B/2 <= [|b|] ->
     let (q,r) := w2_div21 a1 a2 b in
     [|a1|] *w2_B+ [|a2|] = [+|q|] *  [|b|] + [|r|] /\ 0 <= [|r|] < [|b|].
Proof.
 intros a1 a2 b Hle.
 unfold w2_div21.
 assert (H := w2_div_wB_spec a1 b Hle);destruct (w2_div_wB a1 b).
 destruct H as (H,Hltb).
 assert (Hlt:0<[|b|]).  
  unfold w2_B,Zdiv in Hle;simpl in Hle;omega.
 assert (Hle_a1 : [|a1|]*w2_B <= ((w2_B + (w2_B - 2)) * [|b|])).
  replace ((w2_B + (w2_B - 2)) * [|b|]) with ((w2_B -1)*(2*[|b|])).
  apply Zmult_le_compat.
  assert (H1 := w2_to_Z_spec a1);omega.
  change w2_B with (2*(w2_B/2)).
  apply Zmult_le_compat_l;trivial. 
  intro H1;discriminate H1.
  destruct(w2_to_Z_spec a1);trivial.
  intro H1;discriminate H1.
  ring.
 assert ([+|c|] <= w2_B + (w2_B -2)).
  apply Zmult_le_reg_r with [|b|]. 
  omega.
  apply Zplus_le_reg_r with [|w|].
  rewrite <- H.
  apply Zle_trans with ((w2_B + (w2_B - 2)) * [|b|]).
  trivial.
  assert (H1 := w2_to_Z_spec w);omega.
 assert (H1 := w2_add_c_spec w a2);destruct (w2_add_c w a2) as [r|r].
 assert (H2 := w2_compare_spec r b);destruct (w2_compare r b).
 rewrite (w2_carry_succ_c_spec c H0);rewrite H.
 rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1;rewrite H2.
 simpl;split;[ring|omega]. 
 rewrite H;rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1.
 split;[trivial| assert (H3 := w2_to_Z_spec r);omega].
 rewrite (w2_carry_succ_c_spec c H0);rewrite H.
 rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1.
 rewrite (w2_sub_spec r b).
 assert (H3 := w2_to_Z_spec r);assert (H4 := w2_to_Z_spec b).
 change w2_B with (2*(w2_B/2))%Z in H3.
 rewrite Zmod_def_small.
 simpl;split;[ring|omega].  omega. 
 unfold interp_carry in H1;rewrite Zmult_1_l in H1.
 assert ([|r|] < [|b|]).
  apply  Zplus_lt_reg_l with w2_B. 
  rewrite H1;rewrite Zplus_comm;apply Zplus_lt_compat;trivial.
  assert (H2 := w2_to_Z_spec a2);omega.
 assert ([|w2_sub r b|] = w2_B + [|r|] - [|b|]).
  rewrite w2_sub_spec.
  replace (([|r|] - [|b|]) mod w2_B) with ((w2_B + ([|r|] - [|b|])) mod w2_B).
  rewrite Zmod_def_small. ring.
  assert (H3 := w2_to_Z_spec b); assert (H4 := w2_to_Z_spec r);omega.
  rewrite Zmod_plus. rewrite Z_mod_same. simpl;apply Zmod_mod.
  exact (refl_equal Lt). exact (refl_equal Gt). exact (refl_equal Lt).
 rewrite H;rewrite <- Zplus_assoc;rewrite <- H1.
 assert (H4 := w2_compare_spec (w2_sub r b) b);
   destruct (w2_compare (w2_sub r b) b).
 split;[idtac|simpl;auto with zarith].
 rewrite w2_0_spec;rewrite Zplus_0_r.
 rewrite w2_carry_succ_c_spec.
 rewrite (w2_carry_succ_c_spec c H0).
 replace (w2_B + [|r|]) with ([|b|] + [|b|]).
 ring. rewrite H4 in H3;pattern [|b|] at 1;rewrite H3;ring.
 rewrite (w2_carry_succ_c_spec c H0).
 destruct (Zle_lt_or_eq _ _ H0). omega.
 rewrite H5 in H.
 assert (H6:= w2_to_Z_spec r);assert (H7:= w2_to_Z_spec a2);
 assert (H8:= w2_to_Z_spec w);omega.
 split.
 rewrite H3;rewrite (w2_carry_succ_c_spec c H0);ring.
 assert (H5 := w2_to_Z_spec (w2_sub r b));omega.
 rewrite w2_carry_succ_c_spec.
 rewrite (w2_carry_succ_c_spec c H0).
 rewrite w2_sub_spec.
 rewrite Zmod_def_small.
 split. rewrite H3;ring.  
 assert (H5 := w2_to_Z_spec (w2_sub r b)).
 change w2_B with (2*(w2_B/2)) in H5;omega.
 omega.
 rewrite (w2_carry_succ_c_spec c H0).
 destruct (Zle_lt_or_eq _ _ H0). omega.
 rewrite H5 in H.
 assert (H6:= w2_to_Z_spec r);assert (H7:= w2_to_Z_spec a2);
 assert (H8:= w2_to_Z_spec w);omega.
Qed.

*)

let w_head0 = wt^"_head0"
let w_add_mul_div = wt^"_add_mul_div"
let w_add_mul_div_i i = wt^"_add_mul_div"^(string_of_int i)

let rec nb_head0 n =
 if n = 0 then !digits else nb_head0 (n/2) - 1

let print_lift () = 
  let out = start_file "lift" in
  print_require false "";
 
  print_title "Lift operations";

  print_def w_head0 "x";
  print_match "x";
  for x = 0 to base - 1 do
    let nb = nb_head0 x in
    print " | ";print_w x; print " => ";
    if nb = 0 then println "N0"
    else (print "Npos ";print_pos nb;println "")
  done;
  println  " end.";
  println "";
 
  for i = 1 to !digits - 1 do
    print_def (w_add_mul_div_i i) "x y";
    print_match "x";
    for x = 0 to base - 1 do
      print " | ";print_w x;println " =>";
      print "   ";print_match "y";
      for y = 0 to base - 1 do
	print "    | ";print_w y;print " => ";
            print_w ((x lsl i)+(y lsr (!digits - i)));println ""
      done;
      println "    end";
    done;
    println " end.";
    println "";
  done;

  print_def w_add_mul_div "x y p";
  print_match "p";
  for p = 1 to !digits - 1 do
    print " | ";print_pos p; print " => ";
       print (w_add_mul_div_i p); println " x y"
  done;
  print " | _ => ";print_w 0;println "";
  print " end.";
  println "";
  
  end_file out;
 
  let out = start_file "head0_spec" in
  print_require false "lift";

  println "Lemma Eq_not_Gt : Eq <> Gt.";
  println "Proof. intro H;discriminate H. Qed.";
  println "";

  println "Lemma Lt_not_Gt : Lt <> Gt.";
  println "Proof. intro H;discriminate H. Qed.";
  println "";
 
  let hyp x = "0 < [|"^x^"|]" in
  let concl x = 
    w_B^"/ 2 <= 2 ^ (Z_of_N ("^w_head0^" "^x^")) * [|"^x^"|] < "^w_B in
  let typ x = (hyp x)^" -> "^(concl x) in
  print_spec w_head0 "x" (typ "x");
  print_fun "x";
  print_match_dep "x" (typ "x");
  print " | ";print_w 0;print " => ";
  print "   fun (H:";print (hyp (string_w 0));println ") =>";
  println "    eq_ind Eq";
  println "      (fun ee : comparison =>";
  println "       match ee with";
  println "       | Eq => True";
  print   "       | Lt => ";println (concl (string_w 0));
  println "       | Gt => False";
  println "       end) I Lt H";
  for x = 1 to base - 1 do
    print " | ";print_w x;print " => ";
    print "   fun (H:";print (hyp (string_w x));println ") => ";
    let nb0 = nb_head0 x in
    if x lsl (nb_head0 x) = base / 2 then
      print "     conj (Eq_not_Gt) (refl_equal Lt)"
    else 
      print "     conj (Lt_not_Gt) (refl_equal Lt)";
    println ""
  done;
  println " end.";
  println "";

  end_file out;
 
  for i = 1 to !digits - 1 do
    let out = start_file ("add_mul_div_"^(string_of_int i)^"_spec") in
    print_require false "lift";

    let typ x y =
      "[| "^(w_add_mul_div_i i)^" "^x^" "^y^"|] = "^
         "([|"^x^"|] * (Zpower 2 (Zpos "^(string_of_int i)^")) + "^
          "[|"^y^"|] / (Zpower 2 ((Zpos "^(string_of_int !digits)^
           ") - (Zpos "^(string_of_int i)^")))) mod "^w_B in
    print_spec (w_add_mul_div_i i) "x y" (typ "x" "y");
    print_fun "x y";
    print_match_dep "x" (typ "x" "y");
    for x = 0 to base - 1 do
      print " | ";print_w x;println " =>";
      print "   ";print_match_dep "y" (typ (string_w x) "y");
      for y = 0 to base - 1 do 
	print "    | ";print_w y;print " => refl_equal ";
	printi (((x lsl i)+(y lsr (!digits - i))) mod base);println ""
      done;
      println "    end";
    done;
    println " end.";
    println "";
  
    end_file out
  done;

  let out = start_file "add_mul_div_spec" in
  print_require false "lift";
  print "Require Import ";print !basename;println "_head0_spec."; 
  for i = 1 to !digits - 1 do
  print "Require Import ";print !basename;
    println  ("_add_mul_div_"^(string_of_int i)^"_spec.")
  done;

  let hyp p = "0 < Zpos "^p^" < Zpos "^(string_of_int !digits) in
  let concl x y p = 
     "[| "^w_add_mul_div^" "^x^" "^y^" "^p^"|] = "^
         "([|"^x^"|] * (Zpower 2 (Zpos "^p^")) + "^
          "[|"^y^"|] / (Zpower 2 ((Zpos "^(string_of_int !digits)^
           ") - (Zpos "^p^")))) mod "^w_B in
  let typ x y p = (hyp p)^" -> "^(concl x y p) in
  let rec print_proof i =
    print " assert (H";printi i;print":Zpos p <= ";printi i;
    println "). omega.";
    print " destruct (Zle_lt_or_eq _ _ H";printi i;print ") as [Hlt";
    printi i;print"|Heq";printi i;println "].";
    if i = 1 then 
      println " elimtype False;omega."
    else
      print_proof (i-1);
    print " inversion Heq";printi i;println ".";
    print " exact (";print w_add_mul_div;printi i;println "_spec x y)."
  in
  print_lemma w_add_mul_div "x y p" (typ "x" "y" "p");
  println " intros x y p H.";
  print_proof (!digits - 1);
  println "Qed.";
  println "";

  end_file out

let w_op = wt^"_op"

let print_op () =
  let out = start_file "op" in
  print "Require Export ";print !basename;println "_basic.";
  print "Require Export ";print !basename;println "_compare.";
  print "Require Export ";print !basename;println "_opp.";
  print "Require Export ";print !basename;println "_add.";
  print "Require Export ";print !basename;println "_sub.";
  print "Require Export ";print !basename;println "_mul.";
  print "Require Export ";print !basename;println "_div.";
  print "Require Export ";print !basename;println "_lift.";
  println "Require Import ZnZ.";
  println "";
  println "";

  print_title ("Record of basic operators for base "^(string_of_int base));

  print_def w_op "";
  print    " mk_znz_op ";printi !digits; println "";
  print    "       ";print w_to_Z; println (" "^w_of_pos^" "^w_head0);
  print    "       ";print_w 0;print " ";print_w 1;print " ";
                                            print_w (base-1);println ""; 
  println ("       "^w_WW^" "^w_CW);
  println ("       "^w_compare);
  println ("       "^w_opp_c^" "^w_opp_carry);
  println ("       "^w_succ_c); 
  println ("       "^w_add_c^" "^w_add_carry_c^" "^w_add);
	      println ("       "^w_pred_c); 
  println ("       "^w_sub_c^" "^w_sub_carry_c^" "^w_sub);
  println ("       "^w_mul_c^" "^w_mul^" "^w_square_c); 
  println ("       "^w_div21^" "^w_add_mul_div^"."); 
  println "";

  end_file out;
 
  let out = start_file "op_spec" in
  print_require true "op";
  print "Require Import ";print !basename;println "_opp_spec.";
  print "Require Import ";print !basename;println "_compare_spec.";
  print "Require Import ";print !basename;println "_succ_c_spec.";
  print "Require Import ";print !basename;println "_add_c_spec.";
  print "Require Import ";print !basename;println "_add_carry_c_spec.";
  print "Require Import ";print !basename;println "_add_spec.";
  print "Require Import ";print !basename;println "_pred_c_spec.";
  print "Require Import ";print !basename;println "_sub_c_spec.";
  print "Require Import ";print !basename;println "_sub_carry_c_spec.";
  print "Require Import ";print !basename;println "_sub_spec.";
  print "Require Import ";print !basename;println "_mul_c_spec."; 
  print "Require Import ";print !basename;println "_mul_spec."; 
  print "Require Import ";print !basename;println "_square_c_spec."; 
  print "Require Import ";print !basename;println "_div_spec."; 
  print "Require Import ";print !basename;println "_head0_spec."; 
  print "Require Import ";print !basename;println "_add_mul_div_spec."; 
  println "Require Import ZnZ.";

  println ("Lemma "^w_op^"_spec : znz_spec "^w_op^".");
  println ("Proof.");
  println " apply mk_znz_spec.";
  println (" exact "^w_to_Z^"_spec.");
  println (" exact "^w_of_pos^"_spec.");
  println (" exact "^w_0^"_spec.");
  println (" exact "^w_1^"_spec.");
  println (" exact "^w_Bm1^"_spec.");
  println (" exact "^w_WW^"_spec.");
  println (" exact "^w_CW^"_spec.");
  println (" exact "^w_compare^"_spec.");
  println (" exact "^w_opp_c^"_spec.");
  println (" exact "^w_opp_carry^"_spec.");
  println (" exact "^w_succ_c^"_spec.");
  println (" exact "^w_add_c^"_spec.");
  println (" exact "^w_add_carry_c^"_spec.");
  println (" exact "^w_add^"_spec.");
  println (" exact "^w_pred_c^"_spec.");
  println (" exact "^w_sub_c^"_spec.");
  println (" exact "^w_sub_carry_c^"_spec.");
  println (" exact "^w_sub^"_spec.");
  println (" exact "^w_mul_c^"_spec.");
  println (" exact "^w_mul^"_spec.");
  println (" exact "^w_square_c^"_spec.");
  println (" exact "^w_div21^"_spec.");
  println (" exact "^w_head0^"_spec.");
  println (" exact "^w_add_mul_div^"_spec.");
  println ("Qed.");
  println "";

  end_file out

  

let _ =
 if !all then 
   begin
     print_basic ();
     print_compare ();
     print_opp ();
     print_add ();
     print_sub ();
     print_mul ();
     print_div ();
     print_lift ();
     print_op ()
   end
 else
   begin
     if !compare then print_compare ();
     if !opp then print_opp ();
     if !add then print_add ();
     if !sub then print_sub ();
     if !mul then print_mul ();
     if !div then print_div ();
     if !lift then print_lift ();
     if !op then print_op ()
   end
 

(*


    





          














  
*)
