\section{Conclusions}


The main contribution of our work is to present a certified library for performing
modular arithmetic. Individual arithmetic functions have already been proved correct,
see for example~\cite{BerMagZim02}. To our knowledge, it is the first time verification
has been applied successfully to a complete library  with non-trivial algorithms.
Our motivation was to improve integer arithmetic inside {\sc Coq}. The figures given in Section~\ref{bench} 
show that this goal has been reached: we are now capable of manipulating numbers with more than 13000 digits.
These tests also show all the benefit we could get from a native base arithmetic. We hope this will motivate 
researchers to integrate machine word arithmetic inside {\sc Coq}.

Expressing the arithmetic in the logic has a price: no side effect is possible, 
also numbers are allocated progressively, not in one block.
A natural continuation of our work would be to prove the correctness of a library with side effects.
This would require a much more intensive verification work since in-place computing
is known to be much harder to verify.
Note that directly integrating an existing library inside the prover with no verification
would go against the philosophy of {\sc Coq} to keep its trusted computing base as small
as possible.

From the methodological point of view, the most interesting aspect of this work
has been the use of the meta-proving technique to generate our base arithmetic. This has proved
to be a very powerful technique. Files for the base arithmetic are generated in an ad-hoc manner
by concatenating strings. Developing a more adequate support for meta-proving inside the prover seems a
very promising future work. Note that meta-proving could also be a solution to get more flexibility
in the proof system. Slightly changing our representation, for example adding not only {\tt WO}
but also {\tt W1} and {\tt W-1} to  the {\tt w2} type, would break most of our definitions and proofs.
Meta-proving could be a solution for having a formal development for a family of data structures rather than
just a single one.

Finally, on December 2005, a new prime Mersenne number has been discovered: $2 ^{30402457} - 1$.
It took five days to  perform its Lucas-Lehmer test on a super computer. 
The program uses a very intriguing algorithm for 
multiplication~\cite{crandall}. 
Proving the correctness of
such an algorithm seems a very challenging task. 
