
let digits = ref 2

let usage_basename = 
  "  -o basename : set the base name of each files to [basename], default is Wn where n is the number of digits \n"

let usage_compare = 
  "  -compare : generate files containing the comparison function and its proof\n"

let usage_opp = 
  "  -opp : generate files containing the opposite functions and there proofs\n"

let usage_add = 
  "  -add : generate files containing the addition functions and there proofs\n"

let usage_sub = 
  "  -sub : generate files containing the subtraction functions and there proofs\n"

let usage_mul = 
  "  -mul : generate files containing the multiplication functions and there proofs\n"

let usage_div = 
  "  -div : generate files containing the division mod and gcd functions and corresponding proofs\n"

let usage_mod = 
  "  -mod : generate files containing the mod and corresponding proofs\n"

let usage_sqrt = 
  "  -sqrt : generate files containing the sqrt and corresponding proofs\n"

let usage_lift = 
  "  -lift : generate files containing the lift function and its proofs\n"
let usage_op = 
  "  -op : generate files containing the record of operators and specifications \n"
let usage_noproof = 
  "  -noproof : generate files with no proof \n"
let usage =  
  "Usage : genW [option] digits\n"^
  " Options are \n" ^
  usage_basename ^
  " if some of the following option are used only the files generated by the options are generated, by default all files are generated\n" ^
  usage_compare ^
  usage_opp ^
  usage_add ^
  usage_sub ^
  usage_mul ^
  usage_div ^
  usage_mod ^
  usage_sqrt ^
  usage_lift ^
  usage_op ^
  usage_noproof
  

let setsize s =
  let n = int_of_string s in
  if n < 2 || n > 12 then begin
    print_string "number of digits should be between 2 and 11\n"; 
    exit 1
  end;
  digits := n

let defaultname = ref true

let basename = ref ""

let setname s = 
  basename := s;
  defaultname := false

let all = ref true
let compare = ref false
let opp = ref false
let add = ref false
let sub = ref false
let mul = ref false
let div = ref false
let pos_mod = ref false
let sqrt = ref false
let lift = ref false
let op = ref false
let noproof = ref false

let set_opt opt = 
  Arg.Unit (fun _ -> all := false; opt := true)

let set_opt1 opt = 
  Arg.Unit (fun _ -> opt := true)
(* ** Parse the arguments ** *)

let _ = 
  Arg.parse
    [("-o",Arg.String setname, "");
     ("-compare",set_opt compare  , "");
     ("-opp",set_opt opp , "");
     ("-add",set_opt add , "");
     ("-sub",set_opt sub , "");
     ("-mul",set_opt mul , "");
     ("-div",set_opt div , "");
     ("-mod",set_opt pos_mod , "");
     ("-sqrt",set_opt sqrt , "");     
     ("-lift",set_opt lift , "");
     ("-op",set_opt op , "");
     ("-noproof",set_opt1 noproof , "")
   ] 
    setsize 
    usage

(* ** compute the base and set basename ** *)

let (base, fd) =     
  let base = 1 lsl !digits in
  let outname = 
    if !defaultname then (basename := "W"^(string_of_int !digits);!basename)
    else !basename in
  (base, outname) 

let print = Format.print_string
let println s = print s;print "\n"
let printi = Format.print_int
let print_title s =
  println "";
  print "(* ** ";print s;println " ** *)";
  println ""

let wt = "w"^(string_of_int !digits)

let print_wt () = print wt;;

let print_def f args =
  print "Definition ";print f;
  if args != "" then (print " ";print args);
  println " :="

let print_spec f args concl =
  print "Lemma "; print f;print "_spec : ";
  if String.length args <> 0 then (print "forall ";print args;print ", ");
  print concl; println ".";
  println "Proof"

let print_lemma f args concl =
  print "Lemma "; print f;print "_spec : ";
  if String.length args <> 0 then (print "forall ";print args;print ", ");
  print concl; println ".";
  println "Proof."

let print_admitted_spec() =
  println ".";
  println "Admitted."

let print_admitted() =
  println "Admitted."

let print_fun args = print "fun ";print args;println" =>"

let print_match args =
  print " match ";print args;println " with"

let print_match_dep arg dep =
  print " match ";print arg;
  print " as ";print arg;print " return ";print dep; println " with"

let string_w n =
  let s = ref "" in
  let n = ref n in
  for i = 1 to !digits do
    let d = if !n mod 2 = 0 then "O" else "I" in
    s := d^(!s);
    n := !n/2
  done;
  !s

let print_w n = print (string_w n)

let print_c n =
  if n < 0 then (print "C1 ";print_w (base + n))
  else 
    if n/base = 0 then (print "C0 ";print_w n)
    else begin 
      assert (n < 2*base - 1);
      print "C1 ";print_w n
    end
    
let rec print_pos_s s n =
  if n <= 1 then print s
  else begin
    if n mod 2 = 0 then print "(xO "
    else print "(xI ";
    print_pos_s s (n/2);print ")"
  end

let print_pos = print_pos_s "xH"

let print_bool b = if b then print "true" else print "false"

let print_notation nota f x =
  print "Notation \"";print nota; print"\" := (";
   print f; print " "; print x;print ")  (at level 0, x at level 99) : ";
   println (wt^"_scope.")

let open_scope () = println ("Open Local Scope "^wt^"_scope.")

let start_file post =
  let outname = !basename^"_"^post^".v" in
  let fd = 
    try 
      Unix.openfile outname [Unix.O_WRONLY;Unix.O_CREAT;Unix.O_TRUNC] 0o640 
    with _ -> 
      print_string ("can not open file "^outname^"\n"); 
      exit 1  in
  let out = Unix.out_channel_of_descr fd in
  set_binary_mode_out out false;
  Format.set_formatter_out_channel out;
  out
  
let end_file out = 
  Format.print_flush ();
  Format.set_formatter_out_channel stdout;
  let fd = Unix.descr_of_out_channel out in
  Unix.close fd

let print_require b r = 
  println "Require Import ZArith.";
  println "Open Local Scope Z_scope.";  
  print "Require Import ";print !basename;println "_basic.";
  if b then 
    (print "Require Import ";print !basename;println "_basic_spec.");
  open_scope ();
  if String.length r <> 0 then
    (print "Require Import ";print !basename;print ("_"^r);println ".");
  println "";
  println ""
  
(* ** Basic definitions ** *)

let w_digits = wt^"_digits"
let w_B = wt^"_B"
let w_to_Z = wt^"_to_Z"
let w_of_pos = wt^"_of_pos"
let w_of_N = wt^"_of_N"
let w_0 = wt^"_0"
let w_1 = wt^"_1"
let w_Bm1 = wt^"_Bm1"
let w_WW = wt^"_WW"
let w_W0 = wt^"_W0"
let w_0W = wt^"_0W"

let print_basic () =
  let out = start_file "basic" in 
  println "Require Import ZArith.";
  println "Require Export Basic_type.";
  println "";
  println "";
  println "Open Local Scope Z_scope.";
  println "";

  print  ("Inductive "^wt^" : Set :=");
  for i = 0 to base - 1 do
    println "";
    print " | "; print_w i;print " : ";print_wt()
  done; println ".";
  println "";

  print_title "Conversion functions with Z, N and positive";

  print "Definition ";print w_B; print " := ";printi base; println ".";
  
  print_def w_to_Z "x";
  print_match "x";
  for i = 0 to base - 1 do
    print  " | ";print_w i;print " => ";printi i;println "";
  done;
  println  " end.";
  println "";

  print_def w_of_pos "p";
  print_match "p";
  for i = 1 to base - 1 do
    print " | ";print_pos i;print " => (N0, ";print_w i;println ")"
  done;
  for i = 0 to base - 1 do
    print " | ";print_pos_s "p" (i+base);
         print " => (Npos p, ";print_w i;println ")"
  done;
  println  " end.";
  println "";

  print_def w_of_N "n";
  print_match "n";
  print    " | N0 => (N0, ";print_w 0;println ")";
  println (" | Npos p => "^w_of_pos^" p");
  println  " end.";
  println "";

  print_title "Constructors for the next level";

  print_def w_WW "xh xl";
  print_match "xh, xl";
  print    " | ";print_w 0;print ", ";print_w 0;println " => W0";
  println  " | _, _ => WW xh xl";
  println "end.";
  println "";
 
  print_def w_W0 "h";
  print_match "h";
  print    " | ";print_w 0;println " => W0";
  print    " | _ => WW h "; print_w 0; println "";
  println "end.";
  println "";

  print_def w_0W "l";
  print_match "l";
  print    " | ";print_w 0;println " => W0";
  print    " | _ => WW "; print_w 0; println " l";
  println "end.";
  println "";

  print_notation "[| x |]" w_to_Z "x";
  print_notation "[+| x |]" ("interp_carry 1 "^w_B^" "^w_to_Z) "x";
  print_notation "[-| x |]" ("interp_carry (-1) "^w_B^" "^w_to_Z) "x";
  print_notation "[|| x ||]" ("zn2z_to_Z "^w_B^" "^w_to_Z) "x";

  end_file out;

  let out = start_file "basic_spec" in
  print_require false "";

  print_title "Proof that the basic functions are correct";

  let typ = "0 <= [|x|] < "^w_B in
  print_spec w_to_Z "x" typ;
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" typ;
  print " | ";print_w 0;println " => conj (Zle_refl 0) (refl_equal Lt)";
  for x = 1 to base - 1 do
    print " | ";print_w x;print " => conj (Zle_0_pos ";
      printi x; println ") (refl_equal Lt)"
  done;
  println "end.";
  end;
  println "";

  let typ p = 
    "Zpos "^p^" = "^w_B^"*(Z_of_N (fst ("^w_of_pos^" "^p^
                               "))) + [|snd ("^w_of_pos^" "^p^")|]" in
  let rec print_m space i mkp =
    let pi = "p"^(string_of_int i) in
    let pi1 = "p"^(string_of_int (i+1)) in
    let p = mkp pi in
    if i = !digits then (print space;print ("refl_equal (Zpos "^p^")"))
    else
      let spacei1 = space^"   " in
      print space; print_match_dep pi (typ p);
      print space;print " | xH => "; println ("refl_equal (Zpos "^
                                                         (mkp "xH")^")");
      print space;print " | xO ";print pi1;println " =>";
      print_m spacei1 (i+1) (fun pi -> mkp ("(xO "^pi^")")); println "";
      print space;print " | xI ";print pi1;println " =>";
      print_m spacei1 (i+1) (fun pi -> mkp ("(xI "^pi^")")); println "";
      print space;print " end" 
  in
  print_spec w_of_pos "p" 
    ("Zpos p = (Z_of_N (fst ("^w_of_pos^" p)))*"^w_B^" + [|snd ("^
                                                     w_of_pos^" p)|]");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "p0";
  println (" eq_ind_r (fun z : Z => Zpos p0 = z + [|snd ("^w_of_pos^" p0)|])");

  print_m "" 0 (fun p -> p);
  println (" (Zmult_comm (Z_of_N (fst ("^w_of_pos^" p0))) "^w_B^").");
  end;
  println "";


  print_spec w_0 "" ("[|"^(string_w 0)^"|] = 0");
  if (!noproof) then print_admitted_spec()
  else begin
  println "(refl_equal 0).";
  end;
  println "";
  
  print_spec w_1 "" ("[|"^(string_w 1)^"|] = 1");
  if (!noproof) then print_admitted_spec()
  else begin
  println "(refl_equal 1).";
  end;
  println "";
 
  print_spec w_Bm1 "" ("[|"^(string_w (base - 1))^"|] = "^w_B^" - 1");
  if (!noproof) then print_admitted_spec()
  else begin
  print "(refl_equal ";printi (base-1);println ").";
  end;
  println "";
		     
  let typ h l = 
    "[||"^w_WW^" "^h^" "^l^"||] = [|"^h^"|] * "^w_B^" + [|"^l^"|]" in
  print_spec w_WW "h l" (typ "h" "l");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "h l";
  print_match_dep "h" (typ "h" "l");
  print " | ";print_w 0;println " => ";
  print "   ";print_match_dep "l" (typ (string_w 0) "l");
  for l = 0 to base - 1 do 
    print "    | ";print_w l;print " => refl_equal ";printi l;
    println ""
  done;
  println "    end";
  for i = 1 to base - 1 do
    print " | ";print_w i;print " => refl_equal ([||";
    print (w_WW^" ");print_w i;println " l||])"
  done;
  println " end.";
  end;
  println "";
 
  let typ h  = "[||"^w_W0^" "^h^"||] = [|"^h^"|] * "^w_B in
  print_spec w_W0 "h" (typ "h");
  if (!noproof) then print_admitted_spec()
  else begin
    print_fun "h";
    print_match_dep "h" (typ "h");
    print " | ";print_w 0; print " => refl_equal ";printi 0;println "";
    for i = 1 to base - 1 do
      print " | ";print_w i;print " => refl_equal ([||";
      print (w_W0^" ");print_w i;println "||])"
    done;
    println " end.";
  end;
  println "";
 
  let typ l  = "[||"^w_0W^" "^l^"||] = [|"^l^"|]" in
  print_spec w_0W "l" (typ "l");
  if (!noproof) then print_admitted_spec()
  else begin
    print_fun "l";
    print_match_dep "l" (typ "l");
    for i = 0 to base - 1 do
      print " | ";print_w i;print " => refl_equal ([||";
      print (w_0W^" ");print_w i;println "||])"
    done;
    println " end.";
  end;
  println "";
      
  end_file out

(* Comparison *)

let w_compare = wt^"_compare"
let w_eq0 = wt^"_eq0"

let print_compare () = 
  let out = start_file "compare" in
  print_require false "";

  print_title "Comparison";
  
  print_def w_compare "x y";
  print_match "x";
  for x = 0 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match "y";
    for y = 0 to x - 1 do
      print "    | ";print_w y; println " => Gt"
    done;
    print "    | ";print_w x; println " => Eq";
    if x < base - 1 then println "    | _ => Lt end"
    else println "    end"
  done;
  println " end.";
  println "";

  print_def w_eq0 "x";
  print_match "x";
  print   " | ";print_w 0;println " => true";
  println " | _ => false";
  println " end.";
  println "";

  end_file out;
  
  let out = start_file "compare_spec" in
  print_require true "compare";

  let typ x y =
     "match "^w_compare^" "^x^" "^y^" return Prop with "^
     " | Eq => [|"^x^"|] = [|"^y^"|]"^
     " | Lt => [|"^x^"|] < [|"^y^"|]"^
     " | Gt => [|"^x^"|] > [|"^y^"|] end" in
  print_spec w_compare "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print " let typ x y := ";print (typ "x" "y");println " in";
  print_match_dep "x" ("typ x y");
  for x = 0 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match_dep "y" ("typ "^(string_w x)^" y");
    for y = 0 to x - 1 do
      print "    | ";print_w y; println " => refl_equal Gt"
    done;
    print "    | ";print_w x; print " => refl_equal ";printi x;println "";
    if x < base - 1 then println "    | _ => refl_equal Lt";
    println "    end"
  done;
  println " end.";
  end;
  println "";

  println "Lemma false_true_A : forall A:Prop, false = true -> A.";
  println " intros A H;  discriminate H.";
  println "Qed.";
  println "";

  let concl x = "[|"^x^"|] = 0" in
  let typ x = w_eq0^" "^x^" = true -> "^(concl x) in
  print_spec w_eq0 "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
    print_fun "x";
    print_match_dep "x" (typ "x");
    print " | ";print_w 0;println " => fun H => refl_equal 0";
    for x = 1 to base - 1 do 
      print " | ";print_w x;println " => fun H => false_true_A (";
      print (concl (string_w x)); println ") H"  
    done;
    println " end.";
  end;  
  println "";
  end_file out
  

let w_opp_c = wt^"_opp_c"
let w_opp = wt^"_opp"
let w_opp_carry = wt^"_opp_carry"

let print_opp () =
  let out = start_file "opp" in
  print_require false "";
  print_title "Opposites";
  
  print_def w_opp_c "x";
  print_match "x";
  print " | ";print_w 0;print " => C0 "; print_w 0;println "";
  for i = 1 to base - 1 do
    print " | ";print_w i;print " => C1 "; print_w (base - i);println ""
  done;
  println  " end.";
  println "";

  print_def w_opp "x";
  print_match "x";
  print " | ";print_w 0;print " => "; print_w 0;println "";
  for i = 1 to base - 1 do
    print " | ";print_w i;print " => "; print_w (base - i);println ""
  done;
  println  " end.";
  println "";
  
  print_def w_opp_carry "x";
  print_match "x";
  for i = 0 to base - 1 do
    print " | ";print_w i;print " => "; print_w (base - i - 1);println ""
  done;
  println  " end.";
  println "";
  end_file out;
 
  let out = start_file "opp_spec" in
  print_require true "opp";
  let typ x = "[-|"^w_opp_c^" x|] = -[|"^x^"|]" in
  print_spec w_opp_c "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal (-";printi x;println ")"
  done;
  println " end.";
  end;
  println "";
 
 let typ x = "[|"^w_opp^" x|] = (-[|"^x^"|]) mod "^w_B in
  print_spec w_opp "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal ";printi ((base -x)mod base);
      println ""
  done;
  println " end.";
  end;
  println "";

  let typ x = "[|"^w_opp_carry^" "^x^"|] = "^w_B^" - [|"^x^"|] - 1" in
  print_spec w_opp_carry "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x"); 
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal ";
    printi (base - x - 1);println ""
  done;
  println " end.";
  end;
  println "";
  end_file out

let w_succ_c = wt^"_succ_c"
let w_carry_succ_c = wt^"_carry_succ_c"
let w_add_c = wt^"_add_c" 
let w_add_carry_c = wt^"_add_carry_c"
let w_succ = wt^"_succ"
let w_add = wt^"_add"
let w_add_carry = wt^"_add_carry"

let print_add () =
  let out = start_file "add" in
  print_require false "";
  print_title "Additions";

  print_def w_succ_c "x";
  print_match "x";
  for i = 0 to base - 1 do
    print  " | ";print_w i;print " => ";print_c (i+1);println "";
  done;
  println  " end.";
  println "";

  print_def w_carry_succ_c "cx";
  println " Eval compute in";
  print_match "cx";
  print    " | C0 x => "; print w_succ_c;println " x";
  println  " | C1 x => ";
  print "   ";print_match "x";
  for x = 0 to base - 1 do 
    print "    | ";print_w x;print " => C1 ";print_w (x+1);println ""
  done;
  println "    end";
  println " end.";
  println "";
  
  print_def w_add_c "x y";
  print_match "x";
  print     " | ";print_w 0;println " => C0 y";
  for x = 1 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match "y";
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => ";
      print_c (x+y);println "";
    done;
    println "    end"
  done;
  println  " end.";
  println "";

  print_def w_add_carry_c "x y";
  print_match "x";
  for x = 0 to base - 2 do
    print " | ";print_w x; println " => ";
    print "   ";print_match "y";
    for y = 0 to base - 1 do
      print "    | ";print_w y; print " => "; print_c (x+y+1);println ""
    done;
    println "    end";
  done;
  print    " | ";print_w (base-1);println " => C1 y";
  println  " end.";
  println "";

  print_def w_succ "x";
  print_match "x";
  for i = 0 to base - 1 do
    print  " | ";print_w i;print " => ";print_w (i+1);println "";
  done;
  println  " end.";
  println "";

  print_def w_add "x y";
  print_match "x";
  print     " | ";print_w 0;println " => y";
  for x = 1 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match "y";
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => ";
      print_w (x+y);println "";
    done;
    println "    end"
  done;
  println  " end.";
  println "";

  print_def w_add_carry "x y";
  print_match "x";
  for x = 0 to base - 2 do
    print " | ";print_w x; println " => ";
    print "   ";print_match "y";
    for y = 0 to base - 1 do
      print "    | ";print_w y; print " => "; print_w (x+y+1);println ""
    done;
    println "    end";
  done;
  print    " | ";print_w (base-1);println " => y";
  println  " end.";
  println "";


  end_file out;
  
  let out = start_file "succ_c_spec" in
  print_require false "add";

  let typ x = "[+|"^w_succ_c^" "^x^"|] = [|"^x^"|] + 1" in
  print_spec w_succ_c "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal (";printi x;println "+1)"
  done;
  println " end.";
  end;
  println "";
 
  let typ x = "[|"^w_succ^" "^x^"|] = ([|"^x^"|] + 1) mod "^w_B in
  print_spec w_succ "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal ((";
           printi x;print "+1) mod ";print w_B;println ")"
  done;
  println " end.";
  end;
  println "";

  let hyp c = "[+|"^c^"|] <= "^w_B^" + ("^w_B^" - 2)" in
  let concl c = "[+|"^w_carry_succ_c^" "^c^"|] = [+|"^c^"|] + 1" in
  let typ c = (hyp c)^" -> "^(concl c) in
  print_spec w_carry_succ_c "c" (typ "c");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "c";
  print_match_dep "c" (typ "c");
  print " | C0 x => fun (H:";print (hyp "C0 x");print ")=> ";
    print w_succ_c;println "_spec x";
  println " | C1 x =>";
  print   "   ";print_match_dep "x" (typ "(C1 x)");
  for x = 0 to base - 2 do
    print "    | ";print_w x;
    print " => fun (H:";print (hyp ("C1 "^(string_w x)));
    print ") => refl_equal ";printi (base+x+1); println ""
  done;
  print "    | ";print_w (base - 1);println " =>";
  print "      fun (H:";print (hyp ("C1 "^(string_w (base-1))));
                                                       println ") =>";
  println "        False_ind";
    print "          (";print (concl ("(C1 "^(string_w (base-1))^")"));
                                                              println ")";
  println "          (H (refl_equal Gt))";
  println "    end";
  println " end.";
  end;
  println "";
  
  end_file out;
    
  let out = start_file "add_c_spec" in
  print_require false "add";

  let typ x y = "[+|"^w_add_c^" "^x^" "^y^"|] = [|"^x^"|] + [|"^y^"|]" in
  print_spec w_add_c "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "x" (typ "x" "y"); 
  print     " | ";print_w 0;println " => refl_equal [|y|]";
  for x = 1 to base - 1 do
    print " | ";print_w x; println " => ";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => refl_equal ";
      printi (x+y);println "" 
    done;
    println "    end"
  done;
  println  " end.";
  end;
  println "";
  
  end_file out;
    
  let out = start_file "add_carry_c_spec" in
  print_require false "add";


  let typ x y = 
    "[+|"^w_add_carry_c^" "^x^" "^y^"|] = [|"^x^"|] + [|"^y^"|] + 1" in
  print_spec w_add_carry_c "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "x" (typ "x" "y"); 
  for x = 0 to base - 1 do
    print " | ";print_w x; println " => ";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => refl_equal ";
      printi (x+y+1);println ""
    done;
    println "    end"
  done;
  println  " end.";
  end;
  println "";
 
  end_file out;

  let out = start_file "add_spec" in
  print_require false "add";

  let typ x y =
    "[|"^w_add^" "^x^" "^y^"|] = ([|"^x^"|] + [|"^y^"|]) mod "^w_B in
  print_spec w_add "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "x" (typ "x" "y"); 
  for x = 0 to base - 1 do
    print " | ";print_w x; println " => ";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => refl_equal ";
      printi ((x+y) mod base);println ""
    done;
    println "    end"
  done;
  println  " end.";
  end;
  println "";

  end_file out;

  let out = start_file "add_carry_spec" in
  print_require false "add";

  let typ x y =
    "[|"^w_add_carry^" "^x^" "^y^"|] = ([|"^x^"|] + [|"^y^"|] + 1) mod "^w_B in
  print_spec w_add_carry "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "x" (typ "x" "y"); 
  for x = 0 to base - 1 do
    print " | ";print_w x; println " => ";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print    "    | ";print_w y; print " => refl_equal ";
      printi ((x+y+1) mod base);println ""
    done;
    println "    end"
  done;
  println  " end.";
  end;
  println "";

  end_file out

let w_pred_c = wt^"_pred_c"
let w_sub_c = wt^"_sub_c"
let w_sub_carry_c = wt^"_sub_carry_c"
let w_pred = wt^"_pred"
let w_sub = wt^"_sub"
let w_sub_carry = wt^"_sub_carry"

let print_sub () =
  let out = start_file "sub" in
  print_require false "";
  print_title "Subtractions";
  
  print_def w_pred_c "x";
  print_match "x";
  for i = 0 to base - 1 do
    print    " | "; print_w i;print " => ";print_c (i-1);println ""
  done;
  println  " end.";
  println "";

  print_def w_pred "x";
  print_match "x";
  for i = 0 to base - 1 do
    let r = i - 1 in
    print    " | "; print_w i;print " => ";
    print_w  (if r < 0 then r+base else r);println ""
  done;
  println  " end.";
  println "";
  
  print_def w_sub_c "x y";
  print_match "y";
  print    " | ";print_w 0;println " => C0 x";
  for y = 1 to base - 1 do
    print " | ";print_w y; println " => ";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print    "    | ";print_w x; print " => "; print_c (x-y);println ""
    done;
    println "    end"
  done;
  println  " end.";
  println "";
  
  print_def w_sub_carry_c "x y";
  print_match "y";
  for y = 0 to base - 2 do
    print " | ";print_w y; println " =>";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print    "    | ";print_w x; print " => "; print_c (x-y-1);println ""
    done;
    println "    end"
  done;
  print    " | ";print_w (base-1);println " => C1 x";
  println  " end.";
  println "";

  print_def w_sub "x y";
  print_match "y";
  print    " | ";print_w 0;println " => x";
  for y = 1 to base - 1 do
    print " | ";print_w y; println " =>";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print    "    | ";print_w x; print " => ";
      let r = x - y in
      print_w (if r < 0 then r+base else r);
      println ""
    done;
    println "    end"
  done;
  println  " end.";
  println "";

  print_def w_sub_carry "x y";
  print_match "y";
  for y = 0 to base - 2 do
    print " | ";print_w y; println " =>";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      let r = x - y - 1 in
      print    "    | ";print_w x; print " => "; 
      print_w (if r < 0 then r+base else r);println ""
    done;
    println "    end"
  done;
  print    " | ";print_w (base-1);println " => x";
  println  " end.";
  println "";
  
  end_file out;
 
  let out = start_file "pred_c_spec" in
  print_require false "sub";

  let typ x = " [-|"^w_pred_c^" "^x^"|] = [|"^x^"|] - 1" in
  print_spec w_pred_c "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal (";
   printi ((x-1) mod base); println ")"
  done;
  println " end.";
  end;
  println "";

  let typ x = " [|"^w_pred^" "^x^"|] = ([|"^x^"|] - 1) mod "^w_B in
  print_spec w_pred "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    let r = x - 1 in
    print " | ";print_w x;print " => refl_equal ";
    printi(if r < 0 then r+base else r);println ""
  done;
  println " end.";
  end;
  println "";

  end_file out;

  let out = start_file "sub_c_spec" in
  print_require false "sub";

  let typ x y = "[-|"^w_sub_c^" "^x^" "^y^"|] = [|"^x^"|] - [|"^y^"|]" in
  print_spec w_sub_c "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      print "    | ";print_w x;print " => refl_equal (";
      printi (x-y);println ")"
    done;
    println "   end";
  done;
  println " end.";
  end;
  println "";

  end_file out;

  let out = start_file "sub_carry_c_spec" in
  print_require false "sub";

  let typ x y = 
    "[-|"^w_sub_carry_c^" "^x^" "^y^"|] = [|"^x^"|] - [|"^y^"|] - 1" in
  print_spec w_sub_carry_c "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      print "    | ";print_w x;print " => refl_equal (";
      printi (x-y-1);println ")"
    done;
    println "   end";
  done;
  println " end.";
  end;
  println "";

  end_file out;

  let out = start_file "sub_spec" in
  print_require false "sub";

  let typ x y =
    "[|"^w_sub^" "^x^" "^y^"|] = ([|"^x^"|] - [|"^y^"|]) mod "^w_B in
  print_spec w_sub "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      let r = x - y in
      print "    | ";print_w x;print " => refl_equal (";
                              printi (if r < 0 then r+base else r);println ")"
    done;
    println "   end";
  done;
  println " end.";
  end;
  println "";

  end_file out;

 let out = start_file "sub_carry_spec" in
  print_require false "sub";

  let typ x y = 
    "[|"^w_sub_carry^" "^x^" "^y^"|] = ([|"^x^"|] - [|"^y^"|] - 1) mod "^w_B
  in
  print_spec w_sub_carry "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      let r = x - y - 1 in
      print "    | ";print_w x;print " => refl_equal ";
      printi (if r < 0 then r+base else r);println ""
    done;
    println "   end";
  done;
  println " end.";
  end;
  println "";

  end_file out

let w_mul_c = wt^"_mul_c"
let w_mul = wt^"_mul"
let w_square_c = wt^"_square_c"

let print_mul () =
  let out = start_file "mul" in
  print_require false "";
  print_title "Multiplcations";

  print_def w_mul_c "x y";
  print_match "x";
  print     " | ";print_w 0; print " => W0";println "";
  print     " | ";print_w 1; print " => WW ";print_w 0;println " y";
  for x = 2 to base - 1 do
    print " | ";print_w x; println   " =>";
    print "   ";print_match "y";
    print "    | ";print_w 0;println " => W0";
    print "    | ";print_w 1; print " => WW ";print_w 0;
          print " ";print_w x; println "";
    for y = 2 to base - 1 do
      let prod = x * y in
      print "    | ";print_w y; print " => WW ";
      print_w (prod/base);print " ";print_w prod; println ""
    done;
    println "    end"
  done;
  println  " end.";
  println "";

  print_def w_mul "x y";
  print_match (w_mul_c^" x y");
  print   " | W0 => ";print_w 0;println "";
  println " | WW _ l => l";
  println " end.";
  println "";

  print_def w_square_c "x";
  print_match "x";
  print " | ";print_w 0;println " => W0";
  for x = 1 to base - 1 do
    let xx= x*x in 
    print " | ";print_w x;print " => WW ";
    print_w (xx/base);print " ";print_w xx; println ""
  done;
  println " end.";
  println "";

  end_file out;
 
  let out = start_file "mul_c_spec" in
  print_require false "mul";
  
  let typ x y = 
     "[||"^w_mul_c^" "^x^" "^y^"||] = [|"^x^"|] * [|"^y^"|]" in
  print_spec w_mul_c "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "x" (typ "x" "y");
  print " | ";print_w 0;println " => refl_equal 0";
  for x = 1 to base - 1 do 
    print " | ";print_w x;println " =>";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print "    | ";print_w y; print " => refl_equal ";
      printi (x*y);println ""
    done;
    println "    end"
  done;
  println " end.";
  end;
  println "";
   
  end_file out;
 
  let out = start_file "mul_spec" in
  print_require true "mul";
  println "Require Import ZDivModAux.";
  print "Require Import ";print !basename;println "_mul_c_spec.";
  println "Open Local Scope Z_scope.";
  println "";
  println "";

  let typ x y = 
    "[|"^w_mul^" "^x^" "^y^"|] = ([|"^x^"|] * [|"^y^"|]) mod "^w_B in
  print_lemma w_mul "x y" (typ "x" "y");
  if (!noproof) then print_admitted()
  else begin
  println (" assert (H1: 0 < "^w_B^"). exact (refl_equal Lt).");
  println (" assert (H2: "^w_B^" > 0). exact (refl_equal Gt).");
  println (" unfold "^w_mul^";intros x y.");
  println (" assert (H := "^w_mul_c^"_spec x y); destruct ("^w_mul_c^" x y).");
  println (" rewrite <- H; reflexivity.");
  println (" rewrite <- H; simpl.");
  println (" rewrite Zmod_plus;trivial.");
  println (" rewrite Zmod_mult;trivial.");
  println (" rewrite Z_mod_same;trivial.");
  println (" rewrite Zmult_0_r; rewrite (Zmod_def_small 0).");
  println (" simpl; rewrite Zmod_mod;trivial.");
  println (" rewrite Zmod_def_small;trivial.");
  println (" apply "^w_to_Z^"_spec.");
  println (" split;[intro Heq;discriminate Heq | exact (refl_equal Lt)].");
  println ("Qed.");
  end;
  println "";
 
  end_file out;

  let out = start_file "square_c_spec" in
  print_require false "mul";
 
  let typ x = "[|| "^w_square_c^" "^x^"||] = [|"^x^"|] * [|"^x^"|]" in
  print_spec w_square_c "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal ";printi (x*x);println ""
  done;
  println " end.";
  end;
  println "";

  end_file out


let w_head0 = wt^"_head0"
let w_add_mul_div = wt^"_add_mul_div"
let w_add_mul_div_i i = wt^"_add_mul_div"^(string_of_int i)

let rec nb_head0 n =
 if n = 0 then !digits else nb_head0 (n/2) - 1

let print_lift () = 
  let out = start_file "lift" in
  print_require false "";
 
  print_title "Lift operations";

  print_def w_head0 "x";
  print_match "x";
  for x = 0 to base - 1 do
    let nb = nb_head0 x in
    print " | ";print_w x; print " => ";
    if nb = 0 then println "N0"
    else (print "Npos ";print_pos nb;println "")
  done;
  println  " end.";
  println "";
 
  for i = 1 to !digits - 1 do
    print_def (w_add_mul_div_i i) "x y";
    print_match "x";
    for x = 0 to base - 1 do
      print " | ";print_w x;println " =>";
      print "   ";print_match "y";
      for y = 0 to base - 1 do
	print "    | ";print_w y;print " => ";
            print_w ((x lsl i)+(y lsr (!digits - i)));println ""
      done;
      println "    end";
    done;
    println " end.";
    println "";
  done;

  print_def w_add_mul_div "p";
  print_match "p";
  for p = 1 to !digits - 1 do
    print " | ";print_pos p; print " => "; println (w_add_mul_div_i p)
  done;
  print " | _ => fun x y => ";print_w 0;println "";
  print " end.";
  println "";
  
  end_file out;
 
  let out = start_file "head0_spec" in
  print_require false "lift";

  println "Lemma Eq_not_Gt : Eq <> Gt.";
  if (!noproof) then print_admitted()
  else begin
  println "Proof. intro H;discriminate H. Qed.";
  end;
  println "";

  println "Lemma Lt_not_Gt : Lt <> Gt.";
  if (!noproof) then print_admitted()
  else begin
  println "Proof. intro H;discriminate H. Qed.";
  end;
  println "";
 
  let hyp x = "0 < [|"^x^"|]" in
  let concl x = 
    w_B^"/ 2 <= 2 ^ (Z_of_N ("^w_head0^" "^x^")) * [|"^x^"|] < "^w_B in
  let typ x = (hyp x)^" -> "^(concl x) in
  print_spec w_head0 "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  print " | ";print_w 0;print " => ";
  print "   fun (H:";print (hyp (string_w 0));println ") =>";
  println "    eq_ind Eq";
  println "      (fun ee : comparison =>";
  println "       match ee with";
  println "       | Eq => True";
  print   "       | Lt => ";println (concl (string_w 0));
  println "       | Gt => False";
  println "       end) I Lt H";
  for x = 1 to base - 1 do
    print " | ";print_w x;print " => ";
    print "   fun (H:";print (hyp (string_w x));println ") => ";
    let nb0 = nb_head0 x in
    if x lsl (nb_head0 x) = base / 2 then
      print "     conj (Eq_not_Gt) (refl_equal Lt)"
    else 
      print "     conj (Lt_not_Gt) (refl_equal Lt)";
    println ""
  done;
  println " end.";
  end;
  println "";

  end_file out;
 
  for i = 1 to !digits - 1 do
    let out = start_file ("add_mul_div_"^(string_of_int i)^"_spec") in
    print_require false "lift";

    let typ x y =
      "[| "^(w_add_mul_div_i i)^" "^x^" "^y^"|] = "^
         "([|"^x^"|] * (Zpower 2 (Zpos "^(string_of_int i)^")) + "^
          "[|"^y^"|] / (Zpower 2 ((Zpos "^(string_of_int !digits)^
           ") - (Zpos "^(string_of_int i)^")))) mod "^w_B in
    print_spec (w_add_mul_div_i i) "x y" (typ "x" "y");
    if (!noproof) then print_admitted_spec()
    else begin
    print_fun "x y";
    print_match_dep "x" (typ "x" "y");
    for x = 0 to base - 1 do
      print " | ";print_w x;println " =>";
      print "   ";print_match_dep "y" (typ (string_w x) "y");
      for y = 0 to base - 1 do 
	print "    | ";print_w y;print " => refl_equal ";
	printi (((x lsl i)+(y lsr (!digits - i))) mod base);println ""
      done;
      println "    end";
    done;
    println " end.";
    end;
    println "";
  
    end_file out
  done;

  let out = start_file "add_mul_div_spec" in
  print_require false "lift";
  print "Require Import ";print !basename;println "_head0_spec."; 
  for i = 1 to !digits - 1 do
  print "Require Import ";print !basename;
    println  ("_add_mul_div_"^(string_of_int i)^"_spec.")
  done;

  let hyp p = "Zpos "^p^" < Zpos "^(string_of_int !digits) in
  let concl x y p = 
     "[| "^w_add_mul_div^" "^p^" "^x^" "^y^"|] = "^
         "([|"^x^"|] * (Zpower 2 (Zpos "^p^")) + "^
          "[|"^y^"|] / (Zpower 2 ((Zpos "^(string_of_int !digits)^
           ") - (Zpos "^p^")))) mod "^w_B in
  let typ x y p = (hyp p)^" -> "^(concl x y p) in
  let rec print_proof i =
    print " assert (H";printi i;print":Zpos p <= ";printi i;
    println "). omega.";
    print " destruct (Zle_lt_or_eq _ _ H";printi i;print ") as [Hlt";
    printi i;print"|Heq";printi i;println "].";
    if i = 1 then 
      println " elimtype False;omega."
    else
      print_proof (i-1);
    print " inversion Heq";printi i;println ".";
    print " exact (";print w_add_mul_div;printi i;println "_spec x y)."
  in
  print_lemma w_add_mul_div "x y p" (typ "x" "y" "p");
  if (!noproof) then print_admitted()
  else begin
  println " intros x y p H.";
  println " assert (H0: 0 < Zpos p); [red; simpl; auto | idtac].";
  print_proof (!digits - 1);
  println "Qed.";
  end;
  println "";

  end_file out

let w_div_wB = wt^"_div_wB"
let w_div21 = wt^"_div21"
let w_divn1 = wt^"_divn1"
let w_div = wt^"_div"
let w_mod = wt^"_mod"
let w_modn1 = wt^"_modn1"
let w_gcd = wt^"_gcd"

let rec gcd x y = if y = 0 then x else gcd y (x mod y) 
  
let print_div () =
  let out = start_file "div_aux" in
  print_require false "";
  print_title "Division";

  print_def w_div "x y";
  print_match "y";
  print " | ";print_w 0;print " => (";print_w 0; 
                                      print ", ";print_w 0;println ")"; 
  for y = 1 to base - 1 do
    print " | ";print_w y;println " => ";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print "    | ";print_w x;print " => (";
      print_w (x/y);print ", ";print_w (x mod y);println ")"
    done;
    println "    end"
  done;
  println " end.";
  println "";
  
  print_def w_div_wB "x y";
  print_match "y";
  for y = 0 to base/2 - 1 do
    print " | ";print_w y;print " => (";print_w 0; 
                                      print ", ";print_w 0;println ")"; 
  done;
  for y = base/2 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   ";print_match "x";
    for x = 0 to y - 1 do
      print "    | ";print_w x;print " => (";
      let xB = x*base in 
      let q, r = xB / y, xB mod y in
      print_w q; print ", ";print_w r;println ")";
    done;
    for x = y to base - 1 do 
    print "    | ";print_w x;print " => (";print_w 0; 
                                      print ", ";print_w 0;println ")"; 
    done;
    println "   end";
  done;
  println " end.";
  println "";

  print_def w_mod "x y";
  print_match "y";
  print " | ";print_w 0;print " => ";print_w 0;println "";
  for y = 1 to base - 1 do
    print " | ";print_w y;println " => ";
    print "   ";print_match "x";
    for x = 0 to base - 1 do
      print "    | ";print_w x;print " => ";print_w (x mod y);println ""
    done;
    println "    end"
  done;
  println " end.";
  println "";


  print_def w_gcd "x y";
  print_match "x";
  for x = 0 to base - 1 do
    print " | ";print_w x;println " => ";
    print_match "y";
    for y = 0 to base - 1 do
      print "    | ";print_w y; print " => ";print_w (gcd x y);println "";
    done;
    println "   end";
  done;
  println " end.";
  println "";

  end_file out ;
  
  let out = start_file "div" in
  print_require false "";
  print "Require Import ";print !basename;println "_compare.";
  print "Require Import ";print !basename;println "_add.";
  print "Require Import ";print !basename;println "_sub.";
  print "Require Export ";print !basename;println "_div_aux."; 
  print "Require Export ";print !basename;println "_lift.";
  print_title "Division of two digits by one";
  
  print_def w_div21 "a1 a2 b";
  println (" let (q,s) := "^w_div_wB^" a1 b in");
  println (" match "^w_add_c^" s a2 with");
  println (" | C0 r =>");
  println ("   match "^w_compare^" r b with");
  println ("   | Eq => ("^w_succ^" q, "^(string_w 0)^")");
  println ("   | Lt => (q, r)");
  println ("   | Gt => ("^w_succ^" q, "^w_sub^" r b)");
  println ("   end");
  println (" | C1 r =>");
  println ("   let q := "^w_succ^" q in");
  println ("   let r' := "^w_sub^" r b in");
  println ("   match "^w_compare^" r' b with");
  println ("   | Eq => ("^w_succ^" q, "^(string_w 0)^")");
  println ("   | Lt => (q, r')");
  println ("   | Gt => ("^w_succ^" q, "^w_sub^" r' b)");
  println ("   end");
  println (" end.");
  println "";

  end_file out;
 
  let out = start_file "div_wB_spec" in
  print_require false "div";

  println "Lemma Eq_not_Lt : Eq <> Lt.";
  if (!noproof) then print_admitted()
  else begin
  println "Proof. intro H;discriminate H. Qed.";
  end;
  println "";

  println "Lemma Gt_not_Lt : Gt <> Lt.";
  if (!noproof) then print_admitted()
  else begin
  println "Proof. intro H;discriminate H. Qed.";
  end;
  println "";

  let hyp1 y =  w_B^"/2 <= [|"^y^"|]" in
  let hyp2 x y =  "[|"^x^"|] < [|"^y^"|]" in
  let concl x y = 
    "match "^w_div_wB^" "^x^" "^y^" return Prop with " ^
    "(q,r) => [|"^x^"|] * "^w_B^" = [|q|]*[|"^y^"|] + [|r|] /\\ "^
    "[|r|] < [|"^y^"|] end" in
  let typ1 x y = (hyp2 x y)^" -> "^(concl x y) in
  let typ x y =  (hyp1 y)^" -> "^(hyp2 x y)^" -> "^(concl x y) in
  print_spec w_div_wB "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "y" (typ "x" "y"); 
  for y = 0 to base/2 - 1 do
    print " | ";print_w y; println " =>";
    print "   fun (H:";print (hyp1 (string_w y));println ") => ";
    println "     False_ind";
    print "       (";
    print ((hyp2 "x" (string_w y))^" -> "^(concl "x" (string_w y)));
    println ")";
    println "       (H (refl_equal Gt))"
  done;
  for y = base/2 to base - 1 do
    print " | ";print_w y;println " =>";
    print "   fun (H1:";print (hyp1 (string_w y));println ") => ";
    print "    ";print_match_dep "x" (typ1 "x" (string_w y));
    for x = 0 to y - 1 do 
      print "     | ";print_w x;println " =>"; 
      print "       fun (H2:";print (hyp2 (string_w x) (string_w y));
      println ") =>";
      print "         conj (refl_equal ";
      printi (x*base);println ") (refl_equal Lt)"
    done;
    print "     | ";print_w y;println " =>"; 
    print "       fun (H2:";print (hyp2 (string_w y) (string_w y));
    println ") =>";
    println "       False_ind";
    print "          (";print (concl (string_w y) (string_w y));println ")";
    println "        (Eq_not_Lt H2)";
    for x = y+1 to base - 1 do
      print "     | ";print_w x;println " =>"; 
      print "       fun (H2:";print (hyp2 (string_w x) (string_w y));
      println ") =>";
      println "       False_ind";
      print "          (";print (concl (string_w x) (string_w y));println ")";
      println "        (Gt_not_Lt H2)";
    done;
    println "     end";
  done; 
  println " end.";
  end;
  println "";
 
  let typ x y = "[|"^w_mod^" "^x^" "^y^"|] = Zmod [|"^x^"|] [|"^y^"|]" in
  print_spec w_mod "x y" ("0 < [|y|] -> "^(typ "x" "y"));
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y (H:0<[|y|])";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " => ";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      print "   | ";print_w x;print " => refl_equal ";
      if y = 0 then printi 0 else printi (x mod y); println ""
    done;
    println "   end"
  done;
  println " end.";
  end;
  println "";
  
  print_spec (w_mod^"_gt") "x y" 
    ("[|x|] > [|y|] -> 0 < [|y|] -> "^(typ "x" "y"));
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y (H1:[|x|] > [|y|]) (H2:0<[|y|])";
  println (w_mod^"_spec x y H2.");
  end;
  println "";
     

  let typ x y = "(match "^w_div^" "^x^" "^y^" return Prop with "^
           " (q,r) => ([|q|],[|r|]) = Zdiv_eucl [|"^x^"|] [|"^y^"|] end)" in
  println ("Lemma "^w_div^"_eq : forall x y, "^ (typ "x" "y")^".");
  if (!noproof) then print_admitted()
  else begin
  print "Proof ";print_fun "x y";
  print_match_dep "y" (typ "x" "y");
  for y = 0 to base - 1 do
    print " | ";print_w y;println " => ";
    print "   ";print_match_dep "x" (typ "x" (string_w y));
    for x = 0 to base - 1 do
      print "   | ";print_w x;print " => refl_equal (";
      if y = 0 then  printi 0 else printi (x/y);
      print ", ";
      if y = 0 then printi 0 else printi (x mod y);
      println ")"
    done;
    println "   end"
  done;
  println " end.";
  end;
  println "";
 
  println "Require Import Znumtheory.";
  println "Require Import Pmod.";
  println "";
  let typ x y = "[|"^w_gcd^" "^x^" "^y^"|] = Zgcd [|"^x^"|] [|"^y^"|]" in
  println ("Lemma "^w_gcd^"_eq : forall x y, "^ (typ "x" "y")^".");
  if (!noproof) then print_admitted()
  else begin
  print "Proof ";print_fun "x y";
  print_match_dep "x" (typ "x" "y");
  for x = 0 to base - 1 do
    print " | ";print_w x;println " =>";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      print "    | ";print_w y;print " => refl_equal ";
      printi (gcd x y);println ""
    done;
    println "    end";
  done;
  println " end.";
  end;
    
  println ("Lemma "^w_gcd^"_spec : forall x y, Zis_gcd [|x|] [|y|] [|"^
                           w_gcd^" x y|].");
  if (!noproof) then print_admitted()
  else begin
  println "Proof.";
  println (" intros x y; rewrite ("^w_gcd^"_eq x y).");
  println " apply Zgcd_is_gcd.";
  println "Qed.";
  end;
  println "";

  println ("Lemma "^w_gcd^
             "_gt_spec : forall x y, [|x|] > [|y|] ->Zis_gcd [|x|] [|y|] [|"^
                           w_gcd^" x y|].");
  if (!noproof) then print_admitted()
  else begin
  println "Proof.";
  println (" intros x y H; apply "^w_gcd^"_spec.");
  println "Qed.";
  end;
  println "";

  println "Open Scope Z_scope.";
  println ("Lemma "^w_div^"_spec : forall a b, 0 < [|b|] ->");
  println ("      let (q,r) := "^w_div^" a b in");
  println "      [|a|] = [|q|] * [|b|] + [|r|] /\\ ";
  println "      0 <= [|r|] < [|b|].";
  if (!noproof) then print_admitted()
  else begin
  println "Proof.";
  println (" intros a b Hpos;assert (Heq := "^w_div^"_eq a b).");
  println  " assert (Hde := Z_div_mod [|a|] [|b|] (Zlt_gt _ _ Hpos)).";
  println (" destruct ("^w_div^" a b).");
  println " destruct (Zdiv_eucl [|a|] [|b|]).";
  println " inversion Heq;subst;rewrite Zmult_comm;trivial.";
  println "Qed.";
  end;
  println "";
  
  println "Open Scope Z_scope.";
  println ("Lemma "^w_div^"_gt_spec"^
           " : forall a b, [|a|] > [|b|] -> 0 < [|b|] ->");
  println ("      let (q,r) := "^w_div^" a b in");
  println "      [|a|] = [|q|] * [|b|] + [|r|] /\\ ";
  println "      0 <= [|r|] < [|b|].";
  if (!noproof) then print_admitted()
  else begin
  println "Proof.";
  println (" intros a b Hgt Hpos;exact ("^w_div^"_spec a b Hpos).");
  println "Qed.";
  end;
  println "";
   
  end_file out;

  let out = start_file "div_spec" in
  print_require true "div";
  print "Require Import ";print !basename;println "_compare.";
  print "Require Import ";print !basename;println "_add.";
  print "Require Import ";print !basename;println "_sub."; 
  print "Require Import ";print !basename;println "_compare_spec.";
  print "Require Import ";print !basename;println "_succ_c_spec.";
  print "Require Import ";print !basename;println "_add_c_spec.";
  print "Require Import ";print !basename;println "_sub_spec."; 
  print "Require Import ";print !basename;println "_div_wB_spec."; 
  print "Require Import ";print !basename;println "_add_mul_div_spec."; 
  print "Require Import ";print !basename;println "_head0_spec."; 
  println "Require Import ZDivModAux.";

  println "Open Local Scope Z_scope."; 
  println ("Lemma "^w_div21^"_spec : forall a1 a2 b,");
  println ("     "^w_B^"/2 <= [|b|] ->");
  println ("     [|a1|] < [|b|] ->");
  println ("     let (q,r) := "^w_div21^" a1 a2 b in");
  println ("     [|a1|] *"^w_B^
           "+ [|a2|] = [|q|] *  [|b|] + [|r|] /\\ 0 <= [|r|] < [|b|].");
  if (!noproof) then print_admitted()
  else begin
  println ("Proof.");
  println (" intros a1 a2 b Hle Hlta1b.");
  println (" unfold "^w_div21^".");
  println (" assert (H := "^w_div_wB^"_spec a1 b Hle Hlta1b);");
  println ("   destruct ("^w_div_wB^" a1 b) as (q,s).");
  println (" destruct H as (H,Hltb).");
  println (" assert (Hlt:0<[|b|]).");
  println ("  unfold "^w_B^",Zdiv in Hle;simpl in Hle;omega.");
  println (" assert (Ha1 := "^w_to_Z^"_spec a1).");
  println (" assert (Hb := "^w_to_Z^"_spec b).");
  println (" assert (Hs := "^w_to_Z^"_spec s).");
  println (" assert (Hq := "^w_to_Z^"_spec q).");
  println (" assert (Hqle2: [|q|] <= "^w_B^" - 2).");
  println ("  assert (Hqle1: [|q|] <= "^w_B^" - 1). omega.");
  println ("  destruct (Zle_lt_or_eq _ _ Hqle1). omega.");
  println ("  rewrite H0 in H.");
  println ("  assert ("^w_B^" *[|b|] - [|b|]+ [|s|] <= "^w_B^
           "*[|b|] - "^w_B^"). 2:omega.");
  println ("   replace ("^w_B^" *[|b|] - [|b|]+ [|s|]) with");
  println ("     (("^w_B^" -1)*[|b|] + [|s|]);try ring.");
  println ("   replace ("^w_B^"*[|b|] - "^w_B^") with");
  println ("     (([|b|] - 1)*"^w_B^");try ring.");
  println ("   rewrite <- H.");
  println ("   apply Zmult_le_compat; omega. ");
  println (" assert (H1 := "^w_add_c^"_spec s a2);destruct ("^w_add_c^
           " s a2) as [r|r].");
  println (" assert (H2 := "^w_compare^"_spec r b);destruct ("^w_compare^
           " r b).");
  println (" rewrite ("^w_succ^"_spec q);rewrite H.");
  println (" rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1;rewrite H2.");
  println (" rewrite Zmod_def_small;try omega.");
  println (" simpl;split;[ring|omega].");
  println (" rewrite H;rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1.");
  println (" split;[trivial| assert (H3 := "^w_to_Z^"_spec r);omega].");
  println (" rewrite ("^w_succ^"_spec q);rewrite H.");
  println (" rewrite Zmod_def_small;try omega.");
  println (" rewrite <- Zplus_assoc;simpl in H1;rewrite <- H1.");
  println (" rewrite ("^w_sub^"_spec r b).");
  println (" assert (H3 := "^w_to_Z^"_spec r); change "^w_B^
           " with (2*("^w_B^"/2)) in H3.");
  println (" rewrite Zmod_def_small.");
  println (" simpl;split;[ring|omega].  omega.");
  println (" unfold interp_carry in H1;rewrite Zmult_1_l in H1.");
  println (" assert ([|r|] < [|b|]).");
  println ("  apply  Zplus_lt_reg_l with "^w_B^".");
  println ("  rewrite H1;rewrite Zplus_comm;apply Zplus_lt_compat;trivial.");
  println ("  assert (H2 := "^w_to_Z^"_spec a2);omega.");
  println (" assert ([|"^w_sub^" r b|] = "^w_B^" + [|r|] - [|b|]).");
  println ("  rewrite "^w_sub^"_spec.");
  println ("  replace (([|r|] - [|b|]) mod "^w_B^") with (("^
           w_B^" + ([|r|] - [|b|])) mod "^w_B^").");
  println ("  rewrite Zmod_def_small. ring.");
  println ("  assert (H3 := "^w_to_Z^"_spec b); assert (H4 := "^
           w_to_Z^"_spec r);omega.");
  println ("  rewrite Zmod_plus. rewrite Z_mod_same. simpl;apply Zmod_mod.");
  println 
    ("  exact (refl_equal Lt). exact (refl_equal Gt). exact (refl_equal Lt).");
  println (" rewrite H;rewrite <- Zplus_assoc;rewrite <- H1.");
  println (" assert (Ha2 := "^w_to_Z^"_spec a2).");
  println (" assert (H4 := "^w_compare^"_spec ("^w_sub^" r b) b);");
  println ("   destruct ("^w_compare^" ("^w_sub^" r b) b).");
  println (" split;[idtac|simpl;auto with zarith].");
  println (" rewrite "^w_0^"_spec;rewrite Zplus_0_r.");
  println (" rewrite "^w_succ^"_spec.");
  println (" rewrite "^w_succ^"_spec.");
  println (" rewrite (Zmod_def_small ([|q|]+1));try omega.");
  println (" assert ("^w_B^" + [|r|] =[|b|] + [|b|]).");
  println (" rewrite H4 in H2;pattern [|b|] at 1;rewrite H2;ring.");
  println (" assert ([|q|] < "^w_B^" - 2).");
  println ("   destruct (Zle_lt_or_eq _ _ Hqle2);trivial.");
  println ("   assert ("^w_B^"*[|b|] - ("^w_B^" + [|r|]) + [|s|] <= "^
           w_B^"*[|b|] - "^w_B^").");
  println ("   rewrite H3.");
  println ("   replace ("^w_B^" * [|b|] - ([|b|] + [|b|]) + [|s|]) with");
  println ("     (("^w_B^" - 2)*[|b|] + [|s|]);try ring.");
  println ("   replace ("^w_B^" * [|b|] - "^w_B^") with");
  println ("           (([|b|] - 1) * "^w_B^");try ring.");
  println ("   rewrite <- H5;rewrite <- H.");
  println ("   apply Zmult_le_compat;omega.");
  println ("   omega.");
  println (" rewrite Zmod_def_small;try omega.");
  println (" rewrite H3;ring.");
  println (" split.");
  println (" rewrite H2;rewrite "^w_succ^
            "_spec;rewrite Zmod_def_small;try omega. ring.");
  println (" assert (H5 := "^w_to_Z^"_spec ("^w_sub^" r b));omega.");
  println (" rewrite "^w_succ^"_spec.");
  println (" rewrite "^w_succ^"_spec.");
  println (" rewrite (Zmod_def_small ([|q|]+1));try omega.");
  println (" assert ("^w_B^" + [|r|] > [|b|] + [|b|]). omega.");
  println (" assert ([|q|] < "^w_B^" - 2).");
  println ("   destruct (Zle_lt_or_eq _ _ Hqle2);trivial.");
  println ("   assert ("^w_B^"*[|b|] - ("^w_B^" + [|r|]) + [|s|] <= "^
           w_B^"*[|b|] - "^w_B^").");
  println ("   apply Zle_trans with ("^w_B^
           " * [|b|] - ([|b|] + [|b|]) + [|s|]);try omega.");
  println ("   replace ("^w_B^" * [|b|] - ([|b|] + [|b|]) + [|s|]) with");
  println ("     (("^w_B^" - 2)*[|b|] + [|s|]);try ring.");
  println ("   replace ("^w_B^" * [|b|] - "^w_B^") with");
  println ("           (([|b|] - 1) * "^w_B^");try ring.");
  println ("   rewrite <- H5;rewrite <- H.");
  println ("   apply Zmult_le_compat;omega.");
  println ("   omega.");
  println (" rewrite Zmod_def_small;try omega.");
  println (" rewrite "^w_sub^"_spec.");
  println (" rewrite Zmod_def_small;try omega.");
  println (" split. rewrite H2;ring.");
  println (" assert (H6 := "^w_to_Z^"_spec ("^w_sub^" r b)).");
  println (" change "^w_B^" with (2*("^w_B^"/2)) in H6;omega.");
  println ("Qed.");
  end;
  println "";

  end_file out

let w_pos_mod = wt^"_pos_mod"
let w_pos_mod_i i = wt^"_pos_mod"^(string_of_int i)

let print_pos_mod () =
  let out = start_file "pos_mod" in
  print_require false "";
  print_title "Modulo";
  let r = ref 1 in 
  for i = 1 to !digits - 1 do
    r := !r * 2;
    print_def (w_pos_mod_i i) "x";
    print_match "x";
    for x = 0 to base - 1 do
      print " | ";print_w x;print " => "; print_w (x mod !r);println ""
    done;
    println " end.";
    println "";
  done;
  print_def w_pos_mod "p";
  print_match "p";
  for i = 1 to !digits  - 1 do
    print " | ";print_pos i;print " => "; println  (w_pos_mod_i i)
  done;
  println " | _  => fun x => x ";
  println " end.";
  println "";
  end_file out;

  let r = ref 1 in 
  for i = 1 to !digits - 1 do
    r := !r * 2;
    let out = start_file ("pos_mod_"^(string_of_int i)^"_spec") in
    print_require false "pos_mod";
    let typ x =
      "[| "^(w_pos_mod_i i)^" "^x^"|] = "^
         "[|"^x^"|] mod (Zpower 2 (Zpos "^(string_of_int i)^"))" in
    print_spec (w_pos_mod_i i) "x" (typ "x");
    if (!noproof) then print_admitted_spec()
    else begin
    print_fun "x";
    print_match_dep "x" (typ "x");
    for x = 0 to base - 1 do
      print " | ";print_w x;print " => refl_equal ";
	printi (x mod !r);println ""
    done;
    println " end.";
    end;
    println "";
    end_file out
  done;

  let out = start_file "pos_mod_spec" in
  print_require false "pos_mod";
  print "Require Import ";print !basename; println "_basic_spec.";
  for i = 1 to !digits - 1 do
  print "Require Import ";print !basename;
    println  ("_pos_mod_"^(string_of_int i)^"_spec.")
  done;
  println "";

  println "Lemma Eq_not_Gt : Eq <> Gt.";
  if (!noproof) then print_admitted()
  else begin
  println "Proof. intro H;discriminate H. Qed.";
  end;
  println "";

  println "Lemma Lt_not_Gt : Lt <> Gt.";
  if (!noproof) then print_admitted()
  else begin
  println "Proof. intro H;discriminate H. Qed.";
  end;
  println "";

  let typ x p = 
     "[| "^w_pos_mod^" "^p^" "^x^"|] = "^
         "[|"^x^"|] mod (Zpower 2 (Zpos "^p^"))" in
  print_lemma w_pos_mod "x p" (typ "x" "p");
  if (!noproof) then print_admitted()
  else begin
  println " intros x.";
  println (" case ("^wt^"_to_Z_spec x); intros H1 H2.");
  let v = (int_of_float (0.0001 +. log (float_of_int !digits) /.  log 2.)) + 1 in
  println (" do "^(string_of_int v)^
            " (try (intros p; case p; simpl "^wt^"_pos_mod; clear p));");
  println (" intros; try (apply "^wt^"_pos_mod1_spec");
  for i = 2 to !digits - 1 do
    print ("           || apply "^wt^"_pos_mod"); printi i; println "_spec";
  done;
  println "                  );";
  println " rewrite ZAux.Zmod_def_small; split; auto;"; 
  println " apply Zlt_le_trans with (1 := H2);";
  println (" replace "^wt^"_B with (2 ^ "^(string_of_int !digits)^"); auto;");
  println " apply ZPowerAux.Zpower_le_monotone; try split; red; simpl;";
  println " intros; auto; try (apply Eq_not_Gt || apply Lt_not_Gt).";
  println "Qed.";
  end;
  println "";

  end_file out

  let print_sqrt () =
  let out = start_file "sqrt" in
  print_require false "";
  print_title "Square root";
  print_def (wt^"_is_even ") "x";
  print_match "x";
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => "; print_bool (0 == (x mod 2));println ""
  done;
  println " end.";
  println "";
  let sqrt n = int_of_float (Pervasives.sqrt (float_of_int n)) in
  print_def (wt^"_sqrt2") "x y";
  print_match "x";
  for x = 0 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match "y";
    for y = 0 to base - 1 do
      let s = sqrt (base * x + y) in
      let r = (base * x + y) - s * s in
      print    "    | ";print_w y; print " => ";
      print "("; print_w s; print ", "; print_c r; print ")";println "";
    done;
    println "    end"
  done;
  println  " end.";
  println "";
  print_def (wt^"_sqrt") "x";
  print_match "x";
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => "; print_w (sqrt x); println "";
  done;
  println  " end.";
  println "";

  end_file out;

  let out = start_file "sqrt_spec" in
  print_require false "sqrt";
  print "Require Import ";print !basename; println "_basic_spec.";

  let typ x = 
     "((if "^wt ^"_is_even "^x^" then "^
     " [|"^x^"|] mod 2 = 0 " ^
     " else [|x|] mod 2 = 1): Prop)" in
  print_spec (wt ^"_is_even") "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;print " => refl_equal ";
    printi (x mod 2);println ""
  done;
  println " end.";
  end;
  println "";

  let typ x y = 
     " "^w_B^"/ 4 <= [|"^x^"|] -> let (s,r) := "^wt ^"_sqrt2 "^x^" "^y^" in "^
     "[||WW "^x^" "^y^"||] = [|s|] ^ 2 + [+|r|] /\\ "^
     "[+|r|] <= 2 * [|s|]" in
  print_spec (wt ^"_sqrt2") "x y" (typ "x" "y");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x y";
  print_match_dep "x" (typ "x" "y");
  for x = 0 to base - 1 do
    print " | ";print_w x;println " => ";
    print "   ";print_match_dep "y" (typ (string_w x) "y");
    for y = 0 to base - 1 do
      let s = sqrt (base * x + y) in
      let r = (base * x + y) - s * s in
      print    "    | ";print_w y; print " => ";
      print "fun _ => conj (refl_equal "; printi (base * x + y); print ") (Zle_bool_imp_le ";
      printi r; print " "; printi (2 * s); print " (refl_equal true))";println "";
    done;
    println "    end"
  done;
  println  " end.";
  end;
  println "";


  let typ x = 
     "[|"^wt ^"_sqrt "^x^"|] ^2 <= [|"^x^"|] < "^
     "([|"^wt ^"_sqrt "^x^"|] + 1) ^2" in
  print_spec (wt ^"_sqrt") "x" (typ "x");
  if (!noproof) then print_admitted_spec()
  else begin
  print_fun "x";
  print_match_dep "x" (typ "x");
  for x = 0 to base - 1 do
    print " | ";print_w x;println " => ";
   let s = sqrt x in
   print "conj (Zle_bool_imp_le ";
   printi (s * s); print " "; printi x; print " (refl_equal true))";
   print " (Zlt_cases ";
   printi x; print " "; printi ((s + 1) * (s + 1)); print ")";
  done;
  println  " end.";
  end;
  println "";

  end_file out

(*

    spec_sqrt : forall x,
       [|w_sqrt x|] ^ 2 <= [|x|] < ([|w_sqrt x|] + 1) ^ 2
*)

let w_op = wt^"_op"

let print_op () =
  let out = start_file "op" in
  print "Require Export ";print !basename;println "_basic.";
  print "Require Export ";print !basename;println "_compare.";
  print "Require Export ";print !basename;println "_opp.";
  print "Require Export ";print !basename;println "_add.";
  print "Require Export ";print !basename;println "_sub.";
  print "Require Export ";print !basename;println "_mul.";
  print "Require Export ";print !basename;println "_div.";
  print "Require Export ";print !basename;println "_lift.";
  print "Require Export ";print !basename;println "_pos_mod.";
  print "Require Export ";print !basename;println "_sqrt.";
  println "Require Import ZnZ.";
  println "";
  println "";

  print_title ("Record of basic operators for base "^(string_of_int base));

  print_def w_op "";
  print    " mk_znz_op ";printi !digits; println "";
  print    "       ";print w_to_Z; println (" "^w_of_pos^" "^w_head0);
  print    "       ";print_w 0;print " ";print_w 1;print " ";
                                            print_w (base-1);println ""; 
  println ("       "^w_WW^" "^w_W0^" "^w_0W);
  println ("       "^w_compare^" "^w_eq0);
  println ("       "^w_opp_c^" "^w_opp^" "^w_opp_carry);
  println ("       "^w_succ_c^" "^w_add_c^" "^w_add_carry_c); 
  println ("       "^w_succ^" "^w_add^" "^w_add_carry); 
  println ("       "^w_pred_c^" "^w_sub_c^" "^w_sub_carry_c);
  println ("       "^w_pred^" "^w_sub^" "^w_sub_carry);
  println ("       "^w_mul_c^" "^w_mul^" "^w_square_c);
   
  println ("       "^w_div21^" "^w_div^" "^w_div);
  println ("       "^w_mod^" "^w_mod);
  println ("       "^w_gcd^" "^w_gcd);
  println ("       "^w_add_mul_div^" "^w_pos_mod);
  println ("       "^wt^"_is_even "^wt^"_sqrt2 "^wt^"_sqrt."); 
  println "";

  end_file out;
 
  let out = start_file "op_spec" in
  print_require true "op";
  print "Require Import ";print !basename;println "_opp_spec.";
  print "Require Import ";print !basename;println "_compare_spec.";
  print "Require Import ";print !basename;println "_succ_c_spec.";
  print "Require Import ";print !basename;println "_add_c_spec.";
  print "Require Import ";print !basename;println "_add_carry_c_spec.";
  print "Require Import ";print !basename;println "_add_spec.";
  print "Require Import ";print !basename;println "_add_carry_spec.";
  print "Require Import ";print !basename;println "_pred_c_spec.";
  print "Require Import ";print !basename;println "_sub_c_spec.";
  print "Require Import ";print !basename;println "_sub_carry_c_spec.";
  print "Require Import ";print !basename;println "_sub_spec.";
  print "Require Import ";print !basename;println "_sub_carry_spec.";
  print "Require Import ";print !basename;println "_mul_c_spec."; 
  print "Require Import ";print !basename;println "_mul_spec."; 
  print "Require Import ";print !basename;println "_square_c_spec."; 
  print "Require Import ";print !basename;println "_div_wB_spec."; 
  print "Require Import ";print !basename;println "_div_spec."; 
  print "Require Import ";print !basename;println "_head0_spec."; 
  print "Require Import ";print !basename;println "_add_mul_div_spec."; 
  print "Require Import ";print !basename;println "_pos_mod_spec."; 
  print "Require Import ";print !basename;println "_sqrt_spec."; 
  println "Require Import ZnZ.";

  println ("Lemma "^w_op^"_spec : znz_spec "^w_op^".");
  if (!noproof) then print_admitted()
  else begin
    println ("Proof.");
    println " apply mk_znz_spec.";
    println (" exact "^w_to_Z^"_spec.");
    println (" exact "^w_of_pos^"_spec.");
    println (" exact "^w_0^"_spec.");
    println (" exact "^w_1^"_spec.");
    println (" exact "^w_Bm1^"_spec.");
    println (" exact "^w_WW^"_spec.");
    println (" exact "^w_0W^"_spec.");
    println (" exact "^w_W0^"_spec.");
    println (" exact "^w_compare^"_spec.");
    println (" exact "^w_eq0^"_spec.");
    println (" exact "^w_opp_c^"_spec.");
    println (" exact "^w_opp^"_spec.");
    println (" exact "^w_opp_carry^"_spec.");
    println (" exact "^w_succ_c^"_spec.");
    println (" exact "^w_add_c^"_spec.");
    println (" exact "^w_add_carry_c^"_spec.");
    println (" exact "^w_succ^"_spec.");
    println (" exact "^w_add^"_spec.");
    println (" exact "^w_add_carry^"_spec.");
    println (" exact "^w_pred_c^"_spec.");
    println (" exact "^w_sub_c^"_spec.");
    println (" exact "^w_sub_carry_c^"_spec.");
    println (" exact "^w_pred^"_spec.");
    println (" exact "^w_sub^"_spec.");
    println (" exact "^w_sub_carry^"_spec.");
    println (" exact "^w_mul_c^"_spec.");
    println (" exact "^w_mul^"_spec.");
    println (" exact "^w_square_c^"_spec.");
    println (" exact "^w_div21^"_spec.");
    println (" exact "^w_div^"_gt_spec.");
    println (" exact "^w_div^"_spec.");
    println (" exact "^w_mod^"_gt_spec.");
    println (" exact "^w_mod^"_spec.");
    println (" exact "^w_gcd^"_gt_spec.");
    println (" exact "^w_gcd^"_spec.");
    println (" exact "^w_head0^"_spec.");
    println (" exact "^w_add_mul_div^"_spec.");
    println (" exact "^w_pos_mod^"_spec.");
    println (" exact "^wt^"_is_even_spec.");
    println (" exact "^wt^"_sqrt2_spec.");
    println (" exact "^wt^"_sqrt_spec.");
    println ("Qed.");
  end;
  println "";

  end_file out

  

let _ =
 if !all then 
   begin
     print_basic ();
     print_compare ();
     print_opp ();
     print_add ();
     print_sub ();
     print_mul ();
     print_div ();
     print_pos_mod ();
     print_sqrt ();
     print_lift ();
     print_op ()
   end
 else
   begin
     if !compare then print_compare ();
     if !opp then print_opp ();
     if !add then print_add ();
     if !sub then print_sub ();
     if !mul then print_mul ();
     if !div then print_div ();
     if !pos_mod then print_pos_mod ();
     if !sqrt then print_sqrt ();
     if !lift then print_lift ();
     if !op then print_op ()
   end
 
