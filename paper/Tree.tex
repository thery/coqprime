\section{Numbers as binary trees \label{Tree}}
For the representation of our numbers, we have chosen not a linear but a 
tree-like structure. Given an arbitrary word set {\tt w}, we define
the two-word set {\tt w2 w} as follows 
\begin{verbatim}
Inductive w2 (w: Set): Set :=  
   WW : w -> w -> w2 w.
\end{verbatim}
Arbitrarily we have chosen than high bits are given first, low bits
second. Now using dependent type, we can iterate this process and define
numbers of height {\tt n} that consits in $2^\texttt{n}$ words.
\begin{verbatim}
Fixpoint word (w: Set) (n:nat): Set :=
 match n with
 | O => w
 | S n => w2 (word w n)
 end.
\end{verbatim}
To represent a number, one has to choose an appropriate height.
For example with the booleans as basic words, a minimum
height of 2 is necessary for the number 13. With this height, it is represented 
as  {\tt WW (WW true false) (WW true true)} which has type {\tt word bool 2}.

Following the methodology proposed in~\cite{GreMa} in a similar setting, 
the operations are not going to be directly defined on the type {\tt word}.
Definitions are staggered instead. What is defined is a functor that 
allow to build a two-word arithmetic from a single-word one. To rephrase it,
when defining a new function, we just need to explain how to compute the 
result on two-word values knowing how to compute it on single-word values.
To illustrate this, let us go back to our comparison function in Section~\ref{Z}. 
To mimic the function {\tt Pcompare}, we first suppose the existence
of the comparison on single word
\begin{verbatim}
Variable w_compare: w -> w -> comparison -> comparison.
\end{verbatim}
and then define the function for two-word values
\begin{verbatim}
Definition ww_compare (x y: w2 w) (r: comparison) :=
  match x, y with
     WW xH xL, WW yH yL => w_compare xH yH (w_compare xL yL r) 
  end.
\end{verbatim}
This is not the function that is defined in a library. We can get
a more efficient implementation taking  advantage of the tree-like 
structure and comparing first the high bits.  
\begin{verbatim}
Variable w_cmp: w -> w -> comparison.

Definition ww_cmp (x y: w2 w) :=
  match x, y with
     WW xH xL, WW yH yL => 
       match w_cmp xH yH with 
          Eq  => w_cmp xL yL
       |  cmp => cmp
       end
  end. 
\end{verbatim}
Of course this capacity of choosing between high and low bits alone is
not sufficient to justify our choice of representation. Appropriate and efficient
recursive algorithms have also to be developed for the usual operations. This 
is the main purpose of the following section. The main drawback of our representation
comes from the fact that we are dealing with complete binary trees. So even choosing
carefully the appropriate height, half of the numbers of words could be unnecessary 
to compute the final result. 
To soften this problem, we have extended the definition of {\tt w2} to include an
empty word {\tt W0}. 
\begin{verbatim}
Inductive w2: Set :=  
   W0: w2
|  WW: w -> w -> w2.
\end{verbatim}
For example, the number 13 can be represented at height 3 as
\begin{verbatim}
 WW W0 (WW (WW true false) (WW true true))
\end{verbatim}
With this extension, we loose the unicity of representation. Still, there is a notion
of canonicity, {\tt W0} should always be prefered to a tree full of zeros. Note that in
our development all functions have been carefully written in order to preserve canonicity but
canonicity  is not formally proved since it is not necessary for ensuring safe computations.
The final version of the comparison function is then
\begin{verbatim}
Definition ww_cmp (x y: w2 w) :=
  match x, y with
  | W0, W0 => Eq
  | W0, WW yH yL =>
    match w_cmp w_0 yH with
    | Eq => w_cmp w_0 yL
    | _  => Lt
    end
  | WW xh xl, W0 =>
    match w_cmp xH w_0 with
    | Eq => w_cmp xL w_0
    | _  => Gt
    end
  | WW xH xL, WW yH yL =>
    match w_cmp xH yH with
    | Eq  => w_cmp xL yL
    | cmp => cmp
    end
  end.
\end{verbatim}
where {\tt w\_0} represents the zero for single word.