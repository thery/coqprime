\section{The certified library \label{Op}}
The library we have been developing includes the usual functions:
addition, subtraction, multiplication,  division, square root, gcd, power function
and modulo. 
For each of them, we not only give an implementation but also formally prove 
that the implementation meets its specification. Specifications are expressed 
using predicates over integers. For this, we use two interpretation functions
{\tt [|\ |]} and {\tt [[\ ]]}.
Given a single word element {\tt x}, its corresponding integer value
is {\tt [|x|]}. Given a two-word element {\tt y}, its corresponding
integer value is {\tt [[y]]}. The base of the arithmetic, i.e
the maximum value plus one that fits  one word, is {\tt wB}. From these definitions, the 
following statement holds
\begin{verbatim}
forall x y, [[WW x y]] = [|x|] * wB + [|y|].
\end{verbatim}
Once a function is defined, its correctness has to be proved.
For example for the comparison defined in the previous section,
one needs to prove that if the function {\tt w\_compare} meets its specification
\begin{verbatim}
forall x y,
       match w_compare x y with
       | Eq => [|x|] = [|y|]
       | Lt => [|x|] < [|y|]
       | Gt => [|x|] > [|y|]
       end.
\end{verbatim}
so does the function {\tt ww\_compare}
\begin{verbatim}
forall x y,
       match ww_compare x y with
       | Eq => [[x]] = [[y]]
       | Lt => [[x]] < [[y]]
       | Gt => [[x]] > [[y]]
       end.
\end{verbatim}

\subsection{Words and carries}

Carries are important for operations like addition and subtraction.
In our functional setting, carries encapsultes words
\begin{verbatim}
Inductive carry (w: Set): Set :=
  | C0: w -> carry
  | C1: w -> carry.
\end{verbatim}
Two interpretation functions are associated with carries.
One interprets the carry positively: {\tt [+|C1 x|] = wB + [|x|]} and
{\tt [+|C0 x|] = [|x|]}. 
The other one interprets it negatively:
{\tt [-|C1 x|] = [|x|] - wB} and {\tt [-|C0 x|] = [|x|]}.
To illustrate how carries are manipulated, let us consider the successor function.
In our library it is represented by two functions
\begin{verbatim}
w_succ: w -> w -> w
w_succ_c: w -> w -> carry w
\end{verbatim}
The first function represents the modular version, the second one the exact 
version. With these two functions, it is possible to define the version
for two-word elements. For example, the definition for the modular version is
\begin{verbatim}
 Definition ww_succ x :=
  match x with
  | W0 => WW w_0 w_1
  | WW xH xL =>
    match w_succ_c xL with
    | C0 l => WW xH l
    | C1 l => WW (w_succ xH) w_0
    end
  end.
\end{verbatim}
Note that unlike what happens in imperative languages, returning
a carry allocates a memory cell. So in our implementation
we avoid as much as possible to create them.
For some critical pieces of code, we use a continuation passing style,
where functions take two extra arguments that are continuations.
The first continuation corresponds to the code that is called when there is a carry and
the second one when there is not. Also, when we know in advance that the result always 
returns (respectively does not return) a carry, we can call the modular function instead. 
An example of such a situation is a naive implementation of the exact function that adds two to a one
word element by calling twice the successor function.
\begin{verbatim}
 Definition w_add2 x :=
  match w_succ_c x with
  | C0 y => w_succ_c y
  | C1 y => C1 (w_succ y)
  end.
\end{verbatim}
In the case where the first increments has created a carry, we are sure that the second
increment cannot raise any carry so we can directly call the {\tt w\_succ} function.

\subsection{Shifting bits}

If most of the operations works at word level, some functions like the
shifting operation requires to work at a lower level: the bit level.
Surprisingly all the operations we had to perform at bit levels can be built
using a single function
\begin{verbatim}
w_add_mul_div : positive -> w -> w -> w
\end{verbatim}
Evaluating  {\tt (w\_add\_mul\_div p x y)} returns a new word that
is composed for its last {\tt p} bits by the first bits of {\tt y}
and for the remaining bits by the last bits of {\tt x}.
Its specification is the following
\begin{verbatim}
forall x y p, 
 2 ^ p < wB  ->
 [|w_add_mul_div p x y|] =
    ([|x|] * (2 ^ p) + ([|y|] * (2 ^ p)) / wB) mod wB.
\end{verbatim}
Two degenerated versions of this function are of some direct interest. Calling
{\tt w\_add\_mul\_div} with a zero word as second argument implements
the shift left. Calling it with a zero word as third argument implements
the shift right.

\subsection{Divide and conquer algorithms}

\subsubsection{Karatsuba multiplication}
Speeding up the multiplication was the main motivation of our 
tree representation of numbers. The multiplication is represented in our library
by the function
\begin{verbatim}
w_mul: w -> w -> w2 w
\end{verbatim}
and its specification is
\begin{verbatim}
forall x y, [[w_mul_c x y]] = [|x|] * [|y|].
\end{verbatim}
The naive implementation on two-word elements follows the simple equation
\begin{verbatim}
[[WW aH aL]] * [[WW bH bL]] =
  [|aH|] * [|bH|] * wB ^ 2 + 
     ([|aH|] * [|bL|] + [|aL|] * [|bH|]) * wB + [|aL|] * [|bL|].
\end{verbatim}
Thus, performing a multiplication requires four submultiplications.
Karatsuba multiplication~\cite{Karat} saves one of these submultiplications
\begin{verbatim}
[[WW aH aL]] * [[WW bH bL]] =
  let HH := [|aH|] * [|bH|] in
  let LL := [|aL|] * [|bL|] in
  HH + (([|aH|] + [|aL|]) * ([|bH|] + [|bL|]) - HH - LL) * wB + LL.
\end{verbatim}
Note that Karatsuba multiplication is more efficient than the naive one
only when numbers are getting large enough. So our library
includes both implementations. They are used separately to define two
different functors. The functor with the naive multiplication is only used 
for trees of "small" height. 

\subsubsection{Recursive Division}
The general division algorithm that we have implemented is the usual schoolboy 
method that iterates the division of two words by one word. 
It is then crucial to perform this division two by one efficiently. 
The algorithm we have implemented is the one presented in~\cite{RecDiv}.
The idea is to use the recursive call on high bits to guess an approximation 
of the quotient and  then to perform an appropriate adjustment to get the exact quotient.

In our development, the division two by one takes
three words and returns a pair composed of the quotient and the remainder.
\begin{verbatim}
Variable w_div21: w -> w -> w -> w * w
\end{verbatim}
and its specification is 
\begin{verbatim}
forall a1 a2 b,  [|a1|] < [|b|] -> wB / 2 <= [|b|] -> 
  let (q, r) := w_div21 a1 a2 b in
   [[WW a1 a2]] = [|q|] * [|b|] + [|r|] /\ 0 <= [|r|] < [|b|].
\end{verbatim}
The two conditions deserve some explanation.
The first one ensures that the quotient fits in one word.
The second one requires the first bit of the divisor to be a 
one. It ensures that the recursive call computes an approximation 
of the quotient that is not too far from the correct value.

Before defining the function {\tt ww\_div21} for two-word elements,
we need to define the intermediate function  {\tt w\_div32}
that divides three one-word elements by two one-word elements.
Its specification is
\begin{verbatim}
forall a1 a2 a3 b1 b2, 
  [[WW a1 a2]] < [[WW b1 b2]] -> wB / 2 <= [|b1|] ->
  let (q, r) := w_div32 a1 a2 a3 b1 b2 in
  [|a1|] * wB ^ 2 + [|a2|] * wB  + [|a3|] =  
      [|q|] *  [[WW b1 b2]] + [[r]] /\ 0 <= [[r]] < [[WW b1 b2]].
\end{verbatim}
The two conditions play the same roles than the ones for the specification of {\tt w\_div21}.
As the code is a bit intricate, we just explain here how the function
proceeds. It first calls {\tt w\_div21} to divide {\tt a1} and {\tt a2}
by {\tt b1}. This gives a pair {\tt q} and {\tt r} such that
\begin{verbatim}
 [|a1|] * wB + [|a2|] = [|q|] * [|b1|] + [|r|]
\end{verbatim}
{\tt q} is considered as the approximation of quotient.
The second condition in the specification ensures that if this approximation
is not exact, it exceeds the real value of at most two units. So the quotient 
can only be {\tt q}, {\tt q - 1} or {\tt q - 2}. 
As we have 
\begin{verbatim}
 [|a1|] *  wB ^ 2  + [|a2|] * wB + [|a3|] = 
   [|q|] * [[WW b1 b2]] + ([|a3|] + [|r|] * wB - [|q|] * [|b2|])
\end{verbatim}
we know in which situation we are by testing the sign of the candidate
remainder.
In our modular arithmetic, it amounts in checking if the substraction   {\tt (WW r wO) - (q * b2)} 
produces or not a carry.  
If it is positive (no carry), the quotient is {\tt q}. If it is negative (a carry), we
have to consider {\tt q - 1} and add in consequence {\tt (WW b1 b2)} to the candidate remainder.
We test again the sign of this new candidate. If it is positive, the quotient is {\tt q - 1}
otherwise it is {\tt q - 2}.
Now, the definition of {\tt ww\_div21} is straightforward. Forgetting the {\tt W0}
constructor, we have
\begin{verbatim} 
 Definition ww_div21 a1 a2 b :=
  match a1, a2, b with
  ....  
  | WW a1H a1L, WW a2H a2L, WW bH bL =>
        let (q1, r) := w_div32 a1H a1L a2H bH bL in
        match r with
        | W0 => (WW q1 w_0, WW w_0 a2L)
        | WW rH rL =>
          let (q2, s) := w_div32 rH rL a2L b1 b2 in
          (WW q1 q2, s)
        end
  end.
\end{verbatim}
Dividing with {\tt w\_div32} the high part of {\tt a1}, the low part of {\tt a1} and the high part of {\tt a2}
by the high and low parts of {\tt b} gives the high part of the quotient. Dividing again with {\tt w\_div32} 
the high part of the remainder, the low part of the remainder, the low part of {\tt a2} by the high and 
low parts of {\tt b} gives  the low part of the quotient and the remainder.
  
\subsubsection{Recursive Square Root}

The algorithm for computing the square root is similar to the one for division.
It was first described in~\cite{RecSqrt} and has already been formalised in a 
theorem prover~\cite{BerMagZim02}. It requires the number to be split
in four. For this reason it is represented by the following function in our
library
\begin{verbatim}
w_sqrt: w -> w -> w * carry w;
\end{verbatim}
it returns the square root and the rest.
Its specification is
\begin{verbatim}
forall x y,
    wB / 4 <= [|x|] ->
    let (s,r) := w_sqrt2 x y in
    [[WW x y]] = [|s|] ^ 2 + [+|r|] /\ [+|r|] <= 2 * [|s|]
\end{verbatim}
As for division, the input must be large enough so that the recursive call
that computes the approximation is not too far from the exact value. 

The definition of the square root needs a support function that implements a division
by two times a number
\begin{verbatim}
w_div2s: carry w -> w -> w -> carry w * carry w
\end{verbatim}
with its specification
\begin{verbatim}
 forall a1 a2 b,
     wB / 2 <= [|b|] -> [+|a1|] <= 2 * [|b|] ->
     let (q, r) := w_div2s a1 a2 b in
     [+|a1|] * wB + [|a2|] = [+|q|] *  (2 * [|b|]) + [+|r|] /\ 
     0 <= [+|r|] < 2 * [|b|].
\end{verbatim}
The idea of the algorithm is summarized by the following equation
\begin{verbatim}
  [[WW aH aL]] * wB ^ 2 + [[WW bH bL]] =
    let (q , r ) := w_sqrt aH aL in
    let (q1, r1) := w_div2s r bH q in
    [[WW q q1]] ^ 2 + [+|r1|] * wB + [|bL|] - [|q1|] ^ 2 
\end{verbatim}
The element {\tt (WW q q1)} is a possible candidate
for the square root. Because of the condition on
the input, we are sure that the square root is either {\tt (WW q q1)} or
{\tt (WW q q1) - 1}. It is the sign of {\tt [+|r1|] * wB + 
[|bL|] - [|q1|] \^{} 2} that indicates in which situation we are. 