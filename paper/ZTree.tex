\section{Linear versus tree representations of numbers\label{ZTree}}

In the standard library of {\sc Coq}, strictly positive numbers are represented as linear structures, low bits first.

\begin{verbatim}
Inductive positive : Set :=
    xI : positive -> positive 
  | xO : positive -> positive 
  | xH : positive.
\end{verbatim}
 {\tt xH} is 1, {\tt (xO p)} is two times the value of {\tt p}
 and {\tt (xI p)} is two times plus one the value of {\tt p}.
For example, 17 and 18 are represented as {\tt xI (xO (xO (xO (xH))))} and
{\tt xO (xI (xO (xO (xH))))} respectively. The choice of the representation
has some direct impact on the way operations are implemented. To illustrate this on an example,
let us consider the comparison function {\tt Pcmp}. It takes two positive numbers
and returns a comparison value
\begin{verbatim}
Inductive comparison: Set := Eq | Lt | Gt.
\end{verbatim}
As numbers are represented low bits first, to compare two numbers 
one needs to walk down both numbers keeping track of what the current status
of the comparison is. This is what the auxiliary function {\tt Pcompare} does. The main 
function {\tt Pcomp} starts the computation with the initial status being equality.
\begin{verbatim}
Fixpoint Pcompare (x y: positive) (r: comparison): comparison :=
  match x, y with
  |    xH,    xH => r
  |    xH,    _  => Lt
  |    _ ,    xH => Gt
  | xI x', xI y' => Pcompare x' y' r
  | xO x', xO y' => Pcompare x' y' r
  | xI x', xO y' => Pcompare x' y' Gt
  | xO x', xI y' => Pcompare x' y' Lt
  end.
  
Definition Pcmp x y := Pcompare x y Eq.
\end{verbatim}
This is clearly not optimal but it is the best one can do with this 
representation. 
Changing to a high bits first representation would lead to a more efficient
comparison but would penalize other functions like parity checking. 
With this linear data-structure, recursive calls only skip a single bit. 
This is a real limitation. Efficient algorithms for large numbers like 
Karatsuba multiplication~\cite{Karat} use a divide and conquer strategy. 
They require to be able to split numbers in parts efficiently. 
This motivates our representation based on a tree-like structure. 
Given an arbitrary word set {\tt w}, we define the two-word 
set {\tt w2 w} as follows 
\begin{verbatim}
Inductive w2 (w: Set): Set :=  
   WW : w -> w -> w2 w.
\end{verbatim}
Arbitrarily we choose that high bits are given first, low bits
second. Now using dependent type, we iterate this process and define
the type of numbers of height {\tt n} as
\begin{verbatim}
Fixpoint word (w: Set) (n:nat): Set :=
 match n with
 |   O => w
 | S n => w2 (word w n)
 end.
\end{verbatim}
An object of type {\tt (word w n)} is a complete binary tree that
contains $2^\texttt{n}$ objects of type {\tt w}.
To represent a given number exactly, one has to choose an appropriate height.
For example, taking the usual booleans for base words, a minimum
height of 2 is necessary to represent the number 13. With this height, 
numbers have type {\tt (word bool 2)} and 
{\tt (WW (WW true true) (WW false true))} denotes the number 13.

Following the methodology proposed in~\cite{GreMa} in a similar setting, 
the operations are not going to be defined on the type {\tt word} directly.
Definitions are staggered instead. What is defined is a functor that 
allows to build a two-word modular arithmetic on top of a single-word one.
In the following, $x,\ y$ are used to denote single-word variables and $xx,\ yy$ 
to denote two-word variables. 
When defining a new function $f$, we just explain how to compute the 
result on two-word values knowing how to compute it on single-word values.
We use the notation $w\_f$ for the single-word version of $f$ and 
$ww\_f$ for the two-word version.
To illustrate this, let us go back to our comparison function. 
To mimic the function {\tt Pcompare}, we first suppose the existence
of the comparison on single words
\begin{verbatim}
Variable w_compare: w -> w -> comparison -> comparison.
\end{verbatim}
and then define the function for two-word values
\begin{verbatim}
Definition ww_compare (xx yy: w2 w) (r: comparison) :=
  match xx, yy with
     WW xH xL, WW yH yL => w_compare xH yH (w_compare xL yL r) 
  end.
\end{verbatim}
This is not the function that is in our library. We can take 
advantage of the tree-like structure and compare high bits first.  
\begin{verbatim}
Variable w_cmp: w -> w -> comparison.

Definition ww_cmp (xx yy: w2 w) :=
  match xx, yy with
     WW xH xL, WW yH yL => 
       match w_cmp xH yH with 
          Eq  => w_cmp xL yL
       |  cmp => cmp
       end
  end. 
\end{verbatim}
The capacity of choosing between high and low bits alone is
not sufficient to justify our choice of representation. What
is important with this representation is that we get for free
the possibility to split numbers in two. The next section 
explains why this property is crucial to implement efficient
algorithms for functions like multiplication, division and square root.
Note that in term of memory allocation, having a tree structure
does not produce any overhead. In a functional setting, building a binary 
tree structure or building the equivalent linear list of words requires the same number of cells.

One main drawback of our representation is that we manipulate only complete 
binary trees. 
So, even if we choose carefully the appropriate height, half of the words 
could be unnecessary to compute the final result. 
To soften this problem, we have extended the definition of {\tt w2} 
to include an empty word {\tt W0}. 
\begin{verbatim}
Inductive w2 (w: Set): Set :=  
   W0: w2
|  WW: w -> w -> w2.
\end{verbatim}
For example, the number 13 can be represented at height 3 as
\begin{verbatim}
 WW W0 (WW (WW true true) (WW false true))
\end{verbatim}
With this extension, we loose the unicity of representation. Still, there is a notion
of canonicity, {\tt W0} should always be preferred to a sub-tree full of zeros. Note that in
our development every function has been carefully written in order to preserve canonicity but
canonicity  is not part of their specification since it is not necessary to ensure safe computations.
Using {\tt w\_0} to represent the zero of single word, 
the final version of the comparison function is then
\begin{verbatim}
Definition ww_cmp (xx yy: w2 w) :=
  match xx, yy with
  | W0, W0 => Eq
  | W0, WW yH yL =>
    match w_cmp w_0 yH with Eq => w_cmp w_0 yL | _  => Lt end
  | WW xh xl, W0 =>
    match w_cmp xH w_0 with Eq => w_cmp xL w_0 | _  => Gt end
  | WW xH xL, WW yH yL =>
    match w_cmp xH yH with Eq  => w_cmp xL yL | cmp => cmp end
  end.
\end{verbatim}


