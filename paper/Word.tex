\section{Implementing base word arithmetic \label{word}}

The final step to complete our library is to define the arithmetic for the 
base words. 
Once defined,  we get the modular arithmetic for the desired size by 
applying an appropriate number of times our functors. 
In a classical implementation, these base words would be machine words.
Unfortunately, machine words are not yet accessible from the {\sc Coq} 
language. 

\subsection{Defined modular arithmetic}

For the moment, the only way to have a modular arithmetic for base words 
inside {\sc Coq} is to define base words as a datatype. 
For example, we have for two-bit words
\begin{verbatim}
Inductive word2 : Set := OO | OI | IO  | II.
\end{verbatim}
The functions are then defined by simple case analysis. For example,
the exact successor function is defined as
\begin{verbatim}
Definition word2_succ_c x :=
 match x with
 | OO => C0 OI
 | OI => C0 IO
 | IO => C0 II
 | II => C1 OO
 end.
\end{verbatim}
We also need to give the proofs that every function meets its specification.
These proofs are also done by case analysis. 

Rather than writing by hand functions and proofs, we have
written an {\sc Ocaml} program~\cite{ocaml} instead.
This program takes the word size as argument and generates the 
desired base arithmetics with all its proofs. 
It is a nice application of meta-proving. Unfortunately, 
functions and their corresponding proofs grow quickly with the word size. 
For example, the addition for {\tt word8} is a pattern matching of 
65536 cases. {\tt word8} is actually the largest size {\sc Coq} can handle. 

The main benefit of  this approach is to get an arithmetic library that is 
entirely expressed in the logic of {\sc Coq}. The library is portable: 
no extension of the {\sc Coq} kernel is needed. 

\subsection{Native modular arithmetic}

To test our library with some machine word arithmetic, we use the extraction
mechanism. 
It converts automatically {\sc Coq} functions into {\sc Ocaml} functions.
It is then possible to run the resulting program with the 31-bit native
{\sc Ocaml} arithmetic or a simulated 64 bit arithmetic. 
Not all the functions that we have implemented have their corresponding 
functions in the native modular arithmetic, 
so some native code had to be developed for these functions.
The formal verification of this code has not yet been completed, but
it is interesting to get a idea of the speed-up we can expect if we add 
native arithmetic in Coq.

