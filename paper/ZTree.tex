\section{Linear versus tree representations of numbers\label{ZTree}}

In the standard library of {\sc Coq}, strictly positive numbers are represented as linear structures, low bits first.

\begin{verbatim}
Inductive positive : Set :=
    xI : positive -> positive 
  | xO : positive -> positive 
  | xH : positive.
\end{verbatim}
The constructor {\tt xI} indicates a one digit, the constructor {\tt xO}
a zero digit and the constructor {\tt xH} the final one digit.
For example, 17 and 18 are represented as {\tt xI (xO (xO (xO (xH))))} and
{\tt xO (xI (xO (xO (xH))))} respectively. The choice of the representation
has some direct impact on the way operations are implemented. To illustrate this on an example,
let us consider the comparison function {\tt Pcmp}. It takes two positive numbers
and returns a comparison value
\begin{verbatim}
Inductive comparison: Set := Eq | Lt | Gt.
\end{verbatim}
As numbers are represented low bits first, to compare two numbers 
one needs to walk down both numbers keeping track of what the current status
of the comparison is. This is what the auxiliary function {\tt Pcompare} does. The main 
function {\tt Pcomp} starts the computation with the initial status being equality.
\begin{verbatim}
Fixpoint Pcompare (x y: positive) (r: comparison): comparison :=
  match x, y with
  |    xH,    xH => r
  |    xH,    _  => Lt
  |    _ ,    xH => Gt
  | xI x', xI y' => Pcompare x' y' r
  | xO x', xO y' => Pcompare x' y' r
  | xI x', xO y' => Pcompare x' y' Gt
  | xO x', xI y' => Pcompare x' y' Lt
  end.
  
Definition Pcmp x y := Pcompare x y Eq.
\end{verbatim}
This is clearly not optimal but it is the best one can do with this representation. 
Changing to a high bits first representation would lead to a more efficient
comparison but would penalize other functions like parity checking. With this linear
datastructure, recursive calls only skip a single bit. 
This is a real limitation. Efficient algorithms for large numbers like Karatsuba 
multiplication~\cite{Karat} use a divide and conquer strategy. They require to be able to split numbers
in parts efficiently. 
This motivates our representation based on a tree-like structure. Given an arbitrary word set {\tt w}, we define
the two-word set {\tt w2 w} as follows 
\begin{verbatim}
Inductive w2 (w: Set): Set :=  
   WW : w -> w -> w2 w.
\end{verbatim}
Arbitrarily we choose that high bits are given first, low bits
second. Now using dependent type, we iterate this process and define
numbers of height {\tt n} that contain $2^\texttt{n}$ words.
\begin{verbatim}
Fixpoint word (w: Set) (n:nat): Set :=
 match n with
 |   O => w
 | S n => w2 (word w n)
 end.
\end{verbatim}
To represent a given number exactly, one has to choose an appropriate height.
For example, taking the usal booleans for basic words, a minimum
height of 2 is necessary to represent the number 13. With this height, 
numbers have type {\tt (word bool 2)} and 13 is represented 
as {\tt (WW (WW true false) (WW true true))}.

Following the methodology proposed in~\cite{GreMa} in a similar setting, 
the operations are not going to be defined on the type {\tt word} directly.
Definitions are staggered instead. What is defined is a functor that 
allows to build a two-word modular arithmetic on top of a single-word one. To rephrase it,
when defining a new function, we just explain how to compute the 
result on two-word values knowing how to compute it on single-word values.
To illustrate this, let us go back to our comparison function. 
To mimic the function {\tt Pcompare}, we first suppose the existence
of the comparison on single words
\begin{verbatim}
Variable w_compare: w -> w -> comparison -> comparison.
\end{verbatim}
and then define the function for two-word values
\begin{verbatim}
Definition ww_compare (x y: w2 w) (r: comparison) :=
  match x, y with
     WW xH xL, WW yH yL => w_compare xH yH (w_compare xL yL r) 
  end.
\end{verbatim}
This is not the function that is in our library. We can take 
advantage of the tree-like structure and compare high bits first.  
\begin{verbatim}
Variable w_cmp: w -> w -> comparison.left

Definition ww_cmp (x y: w2 w) :=
  match x, y with
     WW xH xL, WW yH yL => 
       match w_cmp xH yH with 
          Eq  => w_cmp xL yL
       |  cmp => cmp
       end
  end. 
\end{verbatim}
The capacity of choosing between high and low bits alone is
not sufficient to justify our choice of representation. What
is important with this representation is that we get for free
the possibility to split numbers in two. The next section 
explains why this property is crucial to implement efficient
algorithms for functions like multiplication, division, square root.
Note that in term of memory allocation, having a tree structure
does not imply any overhead. Building a tree structure or 
building the equivalent linear list of words require the same number of cells.

One main drawback of our representation is that we manipulate only complete binary trees. 
So even if we choose carefully the appropriate height, half of the words could be unnecessary 
to compute the final result. 
To soften this problem, we have extended the definition of {\tt w2} to include an
empty word {\tt W0}. 
\begin{verbatim}
Inductive w2 (w: Set): Set :=  
   W0: w2
|  WW: w -> w -> w2.
\end{verbatim}
For example, the number 13 can be represented at height 3 as
\begin{verbatim}
 WW W0 (WW (WW true false) (WW true true))
\end{verbatim}
With this extension, we loose the unicity of representation. Still, there is a notion
of canonicity, {\tt W0} should always be preferred to a sub-tree full of zeros. Note that in
our development all functions have been carefully written in order to preserve canonicity but
canonicity  is not part of their specificationlabels. since it is not necessary for ensuring safe computations.
The final version of the comparison function is then
\begin{verbatim}
Definition ww_cmp (x y: w2 w) :=
  match x, y with
  | W0, W0 => Eq
  | W0, WW yH yL =>
    match w_cmp w_0 yH with
    | Eq => w_cmp w_0 yL
    | _  => Lt
    end
  | WW xh xl, W0 =>
    match w_cmp xH w_0 with
    | Eq => w_cmp xL w_0
    | _  => Gt
    end
  | WW xH xL, WW yH yL =>
    match w_cmp xH yH with
    | Eq  => w_cmp xL yL
    | cmp => cmp
    end
  end.
\end{verbatim}
where {\tt w\_0} represents the zero for single word.

