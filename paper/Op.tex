\section{The certified library \label{Op}}
Our library includes the usual functions:
comparison, successor, predecessor, complement, addition, subtraction, 
multiplication, square, division, square root, gcd, power and modulo.
Functions work with fixed-size words. It means that we compute modulo
the word size. For addition and subtration, we also provide an exact version
that returns a word and a carry. For multiplication, we also provide an exact version
returning two words. 

Our goal was to provide an arithmetic library that is suitable for the two-level
approach where proofs are replaced by computations of certified semi-decision procedures.
Obviously, the two-level approach is interesting only if the semi-decision procedures evaluate
efficiently inside the prover.
So, we must carefully choose the algorithms we implement.
The semi-decision procedure must also be certified, so  every function of our library must come 
along with its proof of correctness. 

Specifications are expressed 
using predicates over integers. For this, we use two interpretation functions
{$ [|\ |]$} and {$[[\ ]]$}.
Given a single word element $x$, its corresponding integer value
is $[|x|]$. Given a two-word element $y$, its corresponding
integer value is $[[y]]$. The base of the arithmetic, i.e
one plus the maximum value that fits in one word, is $\wB$. From these definitions, the 
following statement holds
$$\forall x\, y,\, [[\WW x  y]] = [|x|] * \wB + [|y|]$$
Once a function is defined, its correctness has to be proved.
For example for the comparison defined in the previous section,
one needs to prove that if the function {\tt w\_compare} meets its specification
$$\begin{array}{l}
\forall x\, y, \,\, \textit{match {\tt w\_compare} x y with} \\
\qquad\,\,\,\,
 |\,\, \texttt{Eq}\,\, \rightarrow [|x|] = [|y|]\,\, | \,\,\texttt{Lt}\,\, \rightarrow [|x|] < [|y|] \,\,
| \,\,\texttt{Gt}\,\, \rightarrow [|x|] > [|y|]\\
\qquad\,\,\,\, \textit{end}
\end{array}
$$
so does the function {\tt ww\_compare}
$$\begin{array}{l}
\forall x\, y, \,\, \textit{match {\tt ww\_compare} x y with} \\
\qquad\,\,\,\,
 |\,\, \texttt{Eq}\,\, \rightarrow [[x]] = [[y]]\,\, | \,\,\texttt{Lt}\,\, \rightarrow [[x]] < [[y]] \,\,
| \,\,\texttt{Gt}\,\, \rightarrow [[x]] > [[y]]\\
\qquad\,\,\,\, \textit{end}
\end{array}
$$

\subsection{Words and carries}

Carries are important for operations like addition and subtraction.
In our functional setting, carries encapsulate words
\begin{verbatim}
Inductive carry (w: Set): Set :=
  | C0: w -> carry
  | C1: w -> carry.
\end{verbatim}
Two interpretation functions are associated with carries.
One interprets the carry positively: $\ICP{\CI x} = \wB + [|x|]$ and
$\ICP{\CO x} = [|x|]$. 
The other one interprets it negatively:
$\ICM{\CI x} = [|x|] - \wB$ and $\ICM{\CO x} = [|x|]$.
To illustrate how carries are manipulated, let us consider the successor function.
In our library, it is represented by two functions
\begin{verbatim}
w_succ: w -> w
w_succ_c: w -> carry w
\end{verbatim}
The first function represents the modular version, the second one the exact 
version. With these two functions, it is possible to define the version
for two-word elements. For example, the definition for the modular version is
\begin{verbatim}
 Definition ww_succ x :=
  match x with
  | W0 => WW w_0 w_1
  | WW xH xL =>
    match w_succ_c xL with
    | C0 l => WW xH l
    | C1 l => WW (w_succ xH) w_0
    end
  end.
\end{verbatim}
Note that unlike what happens in imperative languages, returning
a carry allocates a memory cell. So in our implementation
we avoid as much as possible to create them. When we know in advance 
that the result always returns (respectively does not return) a carry, we can call the modular function instead. 
An example of such a situation is a naive implementation of the exact function that adds two to a 
one-word element by calling twice the successor function.
\begin{verbatim}
 Definition w_add2 x :=
  match w_succ_c x with
  | C0 y => w_succ_c y
  | C1 y => C1 (w_succ y)
  end.
\end{verbatim}
In the case where the first increments has created a carry, we are sure that the second
increment cannot raise any carry so we can directly call the {\tt w\_succ} function.
Also, we use a combination of partial evaluation and continuation passing style to get
shorter definitions. This has proved to ease considerably the proving phase without
changing the efficiency of functions.

\subsection{Shifting bits}

If most of the operations works at word level, some functions like the
shifting operation require to work at a lower level: the bit level.
Surprisingly, all the operations we had to perform at bit level can be built
using a single function
\begin{verbatim}
w_add_mul_div : positive -> w -> w -> w
\end{verbatim}
Evaluating  {\tt (w\_add\_mul\_div p x y)} returns a new word that
is composed for its last {\tt p} bits by the first bits of {\tt y}
and for the remaining bits by the last bits of {\tt x}.
Its specification is 
$$\begin{array}{l}
\forall x\, y\, p, \,\, 2 ^ p < \wB  \Rightarrow \\
\hskip20pt [|\textit{\tt{w\_add\_mul\_div}\, p\, x\, y}|] = ([|x|] * 2 ^ p + ([|y|] * 2 ^ p) / \wB) \,\mod\, \wB
\end{array}
$$
Two degenerated versions of this function are of direct interest. Calling
{\tt w\_add\_mul\_div} with a zero word as second argument implements
the shift left. Calling it with a zero word as third argument implements
the shift right.

\subsection{Divide and conquer algorithms}

\subsubsection{Karatsuba multiplication}
Speeding up the multiplication was the main motivation of our 
tree representation for numbers. The multiplication is represented in our library
by the function
\begin{verbatim}
w_mul_c: w -> w -> w2 w
\end{verbatim}
and its specification is
$$\forall x\, y,\, [[\texttt{w\_mul\_c}\, x\, y]] = [|x|] * [|y|]$$
The naive implementation on two-word elements follows the simple equation
$$\begin{array}{l}
[[\WW {a_h} {a_l}]] * [[\WW {b_h} {b_l}]] =\\
\hskip20pt [|{a_h}|] * [|{b_h}|] * \wB ^ 2 +  ([|{a_h}|] * [|{b_l}|] + [|{a_l}|] * [|{b_h}|]) * \wB + [|{a_l}|] * [|{b_l}|]
\end{array}
$$
Thus, performing a multiplication requires four submultiplications.
Karatsuba multiplication~\cite{Karat} saves one of these submultiplications
$$\begin{array}{l}
[[\WW {a_h} {a_l}]] * [[\WW {b_h} {b_l}]] = \\
\hskip20pt \textit{let}\,\, {h}\, = [|{a_h}|] * [|{b_h}|]\,\, \textit{in}\\
\hskip20pt \textit{let}\,\,\,  {l}\, = [|{a_l}|] * [|{b_l}|]\,\, \textit{in}\\
\hskip20pt {h} * \wB^2 + (([|{a_h}|] + [|{a_l}|]) * ([|{b_h}|] + [|{b_l}|]) - {h} - {l}) * \wB + {l} \qquad\qquad
\end{array}
$$
If the above equation looks simple,  Karatsuba multiplication has been one the most difficult function 
to implement and prove correct.
The difficulty is in the computation of the cross
product $(([|{a_h}|] + [|{a_l}|]) * ([|{b_h}|] + [|{b_l}|]) - {h} - {l})$. 
The inner product cannot be directly computed using the word multiplication: 
both additions $(([|{a_h}|] + [|{a_l}|])$ and $([|{b_h}|] + [|{b_l}|])$ can have a carry, 
so their product fits in two words and a maximum carry of 3.
Also, we know that the final cross product is positive and fits in
two words and a maximum carry of 1. This is useful to optimize the code. For example, 
if the inner product has no carry, we are sure that the subtractions by $h$ and $l$ cannot 
generate a carry. Respectively, if the inner product has a carry of 3,  we are sure that each 
subtraction generates a carry. In both cases, modular subtraction can be used instead of
the exact one. 

Karatsuba multiplication is more efficient than the naive one
only when numbers are large enough. So our library
includes both implementations. They are used separately to define two
different functors. The functor with the naive multiplication is only used 
for trees of "small" height. 

\subsubsection{Recursive Division}
The general division algorithm that we have implemented is the usual schoolboy 
method that iterates the division of two words by one word. 
It is then crucial to perform this division two by one efficiently. 
The algorithm we have implemented is the one presented in~\cite{RecDiv}.
The idea is to use the recursive call on high bits to guess an approximation 
of the quotient and  then to perform an appropriate adjustment to get the exact quotient.

In our development, the division two by one takes
three words and returns a pair composed of the quotient and the remainder.
\begin{verbatim}
Variable w_div21: w -> w -> w -> w * w
\end{verbatim}
and its specification is 
$$\begin{array}{l}
\forall a_1\,\, a_2\,\, b,\, \textit{let}\,\, q,\, r = \texttt{w\_div21}\, a_1\,\, a_2\,\, b\,\, \textit{in}\,\, \\
\hskip10pt [|a_1|] < [|b|] \Rightarrow \wB / 2 \le [|b|] \Rightarrow  [[\WW {a_1} {a_2}]] = [|q|] * [|b|] + [|r|] \land 0 \le [|r|] < [|b|]
\end{array}
$$
The two conditions deserve some explanation.
The first one ensures that the quotient fits in one word.
The second one requires the first bit of the divisor to be a 
one. It ensures that the recursive call computes an approximation 
of the quotient that is not too far from the correct value.

Before defining the function {\tt ww\_div21} for two-word elements,
we need to define the intermediate function  {\tt w\_div32}
that divides three one-word elements by two one-word elements.
Its specification is
$$\begin{array}{l}
\forall a_1\,\, a_2\,\, a_3\,\, b_1\,\, b_2, \,\, \textit{let}\,\, q,\, r = \texttt{w\_div32}\,\, a_1\,\, a_2\,\, a_3\,\, b_1\,\, b_2\,\, \textit{in}\\
 \hskip20pt [[\WW {a_1} {a_2}]] < [[\WW {b_1} {b_2}]] \Rightarrow \wB / 2 \le [|b_1|] \Rightarrow\\
 \hskip30pt [|a_1|] * \wB ^ 2 + [|a_2|] * \wB  + [|a_3|] =   [|q|] *  [[\WW {b_1} {b_2}]] + [[r]] \,\,\land  \\
 \hskip30pt 0 \le [[r]] < [[\WW {b_1} {b_2}]]
\end{array}
$$
The two conditions play the same roles than the ones for the specification of {\tt w\_div21}.
As the code is a bit intricate, we just explain here how the function
proceeds. It first calls {\tt w\_div21} to divide $a_1$ and $a_2$
by $b_1$. This gives a pair $q$ and $r$ such that
$$[|a_1|] * \wB + [|a_2|] = [|q|] * [|b_1|] + [|r|]$$
$q$ is considered as the approximation of the final quotient.
The condition $\wB / 2 \le [|b_1|]$ ensures that if this approximation
is not exact, it exceeds the real value of at most two units. So the quotient 
can only be $q$, $q - 1$ or $q - 2$. 
As we have 
$$[|a_1|] *  \wB ^ 2  + [|a_2|] * \wB + [|a_3|] = [|q|] * [[\WW {b_1} {b_2}]] + ([[\WW r {a_3}]] - [|q|] * [|b_2|])$$
we know in which situation we are by testing the sign of the candidate
remainder.
In our modular arithmetic, it amounts in checking if the subtraction of
$(\texttt{w\_mul\_c}\, q\,\, b_2)$ from $(\WW r {a_3}\!)$
produces or not a carry.  
If it is positive (no carry), the quotient is $q$. If it is negative (a carry), we
have to consider $q - 1$ and add in consequence $(\WW {b_1} {b_2}\!)$ to the candidate remainder.
We test again the sign of this new candidate. If it is positive, the quotient is $q - 1$
otherwise it is $q - 2$.
Now, the definition of {\tt ww\_div21} is straightforward. Forgetting the {\tt W0}
constructor, we have
\begin{verbatim} 
 Definition ww_div21 a1 a2 b :=
  match a1, a2, b with
  ....  
  | WW a1H a1L, WW a2H a2L, WW bH bL =>
        let (q1, r) := w_div32 a1H a1L a2H bH bL in
        match r with
        | W0 => (WW q1 w_0, WW w_0 a2L)
        | WW rH rL =>
          let (q2, s) := w_div32 rH rL a2L b1 b2 in
          (WW q1 q2, s)
        end
  end.
\end{verbatim}
These two divisions can only be used if the divisor $b$ is greater than $\wB/2$. This is not restrictive
because if $b$ is too small we can always find a $n$ such that $b* 2 ^n > \wB/2$. If we have $a * 2 ^ n  =  q  * (b * 2 ^ n) + r$ for some $a$ and $r$ then $r$ can be written as $r = 2^n * r'$ so
$a = q * b + r'$. So to perform the division of two numbers of the same size, we first shift
divisor and dividend by $n$. The shifted dividend fits in two words and its hight part is smaller
than the shifted divisor. Then, we use the division of two by one. The resulting
quotient is correct, we just have to unshift the remainder.

\subsubsection{Recursive Square Root}

The algorithm for computing the square root is similar to the one for division.
It was first described in~\cite{RecSqrt} and has already been formalised in a 
theorem prover~\cite{BerMagZim02}. It requires the number to be split
in four. For this reason it is represented by the following function in our
library
\begin{verbatim}
w_sqrt2: w -> w -> w * carry w;
\end{verbatim}
The function returns the square root and the rest.
Its specification is
$$\begin{array}{l}
\forall x\, y,\,\, \textit{let}\,\, s,\, r = \texttt{w\_sqrt2}\, x\, y\,\, \textit{in}\\
\hskip10pt \wB / 4 \le [|x|] \Rightarrow [[\WW x y]] = {[|s|]} ^ 2 + \ICP{r} \land \ICP{r} \le 2 * [|s|]
\end{array}
$$
As for division, the input must be large enough so that the recursive call
that computes the approximation is not too far from the exact value. 

The definition of the square root needs a support function that implements a division
by two times a number
\begin{verbatim}
w_div2s: carry w -> w -> w -> carry w * carry w
\end{verbatim}
with its specification
$$\begin{array}{l}
\forall a_1\,\, a_2\,\, b, \,\, \textit{let}\,\, q,\, r = \texttt{w\_div2s}\,\, a_1\,\, a_2\,\, b\,\, \textit{in}\\
\hskip20pt \wB / 2 \le [|b|] \Rightarrow \ICP{a_1} \le 2 * [|b|] \Rightarrow\\
\hskip30pt \ICP{a_1} * \wB + [|a_2|] = \ICP{q} *  (2 * [|b|]) + \ICP{r} \,\, \land\,\, 0 \le \ICP{r} < 2 * [|b|]
\end{array}
$$
The idea of the algorithm is summarized by the following equation
$$\begin{array}{l}
\textit{let}\,\,\,\, q ,\, r\,\,\, = \texttt{w\_sqrt2}\,\, {a_h}\,\, {a_l}\,\, \textit{in}\\
\textit{let}\,\, q_1 ,\, r_1 = \texttt{w\_div2s}\,\, r\,\, {b_h}\,\, q\,\, \textit{in}\\
{[[\WW {a_h} {a_l}]]} * \wB ^ 2 + [[\WW {b_h} {b_l}]] =
    [[\WW q {q_1}]] ^ 2 + \ICP{r_1} * \wB + [|{b_l}|] - {[|q_1|]} ^ 2 \\
\end{array}
$$
The element $(\WW q {q_1}\!)$ is a possible candidate
for the square root. Because of the condition on
the input, we are sure that the square root is either $(\WW q {q_1}\!)$ or
$(\WW q {q_1}\!) - 1$. It is the sign of $\ICP{r_1} * \wB + 
[|{b_l}|] - [|q_1|] ^ 2$ that indicates in which situation we are. 