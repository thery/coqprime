\section{Linear versus tree representation of numbers\label{ZTree}}

In the standard library of {\sc Coq}, strictly positive numbers are represented as linear structures, low bits first.

\begin{verbatim}
Inductive positive : Set :=
  | xI : positive -> positive 
  | xO : positive -> positive 
  | xH : positive.
\end{verbatim}
 {\tt xH} is 1, {\tt (xO p)} is two times the value of {\tt p}
 and {\tt (xI p)} is two times plus one the value of {\tt p}.
For example, 17 and 18 are represented as {\tt xI (xO (xO (xO (xH))))} and
{\tt xO (xI (xO (xO (xH))))} respectively. The choice of the representation
has some direct impact on the way operations are implemented. To illustrate this on an example,
let us consider the comparison function {\tt Pcmp}. It takes two positive numbers
and returns a comparison value
\begin{verbatim}
Inductive comparison: Set := Eq | Lt | Gt.
\end{verbatim}
As numbers are represented low bits first, to compare two numbers 
one needs to walk down both numbers keeping track of what the current status
of the comparison is. This is what the auxiliary function {\tt Pcompare} does. The main 
function {\tt Pcomp} starts the computation with the initial status being equality.
\begin{verbatim}
Fixpoint Pcompare (x y: positive) (r: comparison): comparison :=
  match x, y with
  |    xH,    xH => r
  |    xH,    _  => Lt
  |    _ ,    xH => Gt
  | xI x', xI y' => Pcompare x' y' r
  | xO x', xO y' => Pcompare x' y' r
  | xI x', xO y' => Pcompare x' y' Gt
  | xO x', xI y' => Pcompare x' y' Lt
  end.
  
Definition Pcmp x y := Pcompare x y Eq.
\end{verbatim}
This is clearly not optimal but is the best one can do with this 
representation: recursive calls only skip a single bit. 
Efficient algorithms for large numbers, like Karatsuba multiplication~\cite{Karat}, 
use a divide and conquer strategy. They require to be able to split numbers in parts efficiently. 
This motivates our representation based on a tree-like structure. 
Given an arbitrary one-word set {\tt w}, we define the two-word  set {\tt w2 w} as follows 
\begin{verbatim}
Inductive w2 (w: Set): Set :=  WW : w -> w -> w2 w.
\end{verbatim}
For example, {\tt (WW true false)} is of type {\tt (w2 bool)}.
We choose in an arbitrary way  that high bits are the first argument of {\tt WW}, low bits
the second one. Now we use a recursive type definition and define
the type of numbers of height {\tt n} as
\begin{verbatim}
Fixpoint word (w: Set) (n:nat): Set :=
 match n with
 |   O => w
 | S n => w2 (word w n)
 end.
\end{verbatim}
An object of type {\tt (word w n)} is a complete binary tree that
contains $2^\texttt{n}$ objects of type {\tt w}. Given a number,
one has to choose an appropriate height to represent it exactly.
For example, taking the usual booleans for base words, a minimum
height of 2 is necessary to represent the number 13. With this height, 
numbers have type {\tt (word bool 2)} and 
{\tt (WW (WW true true) (WW false true))} denotes the number 13.

Arithmetic operations are not going to be defined on the type {\tt word} directly.
We use a technique similar to the one in~\cite{GreMa}. A functor is first defined that 
allows to build a two-word modular arithmetic on top of a single-word one.
The functor is then applied iteratively to get the final implementation.
In the following, $x,\ y$ are used to denote one-word variables and $\textit{xx},\ \textit{yy}$ 
to denote two-word variables. 
When defining a new function $f$, we just need to explain how to compute the 
result on two-word values knowing how to compute it on one-word values.
We use the notation $w\_f$ for the single-word version of $f$ and 
$\textit{ww}\_f$ for the two-word version.
For example, let us go back to our comparison function {\tt Pcompare}
and try to define it on our trees. We first suppose the existence
of the comparison on single words
\begin{verbatim}
Variable w_compare: w -> w -> comparison -> comparison.
\end{verbatim}
and then define the function for two-word values
\begin{verbatim}
Definition ww_compare (xx yy: w2 w) (r: comparison) :=
  match xx, yy with
    WW xH xL, WW yH yL => w_compare xH yH (w_compare xL yL r) 
  end.
\end{verbatim}
This is not the function that is in our library. Instead, we can take 
advantage of the tree-like structure and compare high bits first.  
\begin{verbatim}
Variable w_cmp: w -> w -> comparison.

Definition ww_cmp (xx yy: w2 w) :=
  match xx, yy with
    WW xH xL, WW yH yL => 
     match w_cmp xH yH with Eq => w_cmp xL yL | cmp => cmp end
  end. 
\end{verbatim}
The key property of our representation is that splitting number in two
is for free. The next section details why this property is crucial to implement efficient
algorithms for functions like multiplication, division and square root.
Note that, in term of memory allocation, having a tree structure
does not produce any overhead. In a functional setting, building a binary 
tree structure or building the equivalent linear list of words requires the same number of cells.

One main drawback of our representation is that we manipulate only complete 
binary trees. 
So, even if we choose carefully the appropriate height, half of the words 
could be unnecessary to compute the final result. 
To soften this problem, we have extended the definition of {\tt w2} 
to include an empty word {\tt W0}. 
\begin{verbatim}
Inductive w2 (w: Set): Set :=  
|  W0: w2
|  WW: w -> w -> w2.
\end{verbatim}
For example, the number 13 can be represented at height 3 as
\begin{verbatim}
 WW W0 (WW (WW true true) (WW false true))
\end{verbatim}
With this extension, we lose uniqueness of representation. Still, there is a notion
of canonicity, {\tt W0} should always be preferred to a sub-tree full of zeros. Note that, in
our development, all functions have been carefully written in order to preserve canonicity, but
canonicity  is not part of their specification since it is not necessary to ensure safe computations.
Using {\tt w\_0} to represent the one-word zero, 
the final version of the comparison function is then
\begin{verbatim}
Definition ww_cmp (xx yy: w2 w) :=
  match xx, yy with
  | W0, W0 => Eq
  | W0, WW yH yL =>
     match w_cmp w_0 yH  with Eq => w_cmp w_0 yL  | _   => Lt  end
  | WW xh xl, W0 =>
     match w_cmp xH  w_0 with Eq => w_cmp xL  w_0 | _   => Gt  end
  | WW xH xL, WW yH yL =>
     match w_cmp xH  yH  with Eq => w_cmp xL  yL  | cmp => cmp end
  end.
\end{verbatim}


